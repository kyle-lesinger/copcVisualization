export declare const pbrMaterialUniforms = "uniform Projection {\n  // Projection\n  vec3 u_Camera;\n};\n\nuniform pbrMaterialUniforms {\n  // Material is unlit\n  bool unlit;\n\n  // Base color map\n  bool baseColorMapEnabled;\n  vec4 baseColorFactor;\n\n  bool normalMapEnabled;  \n  float normalScale; // #ifdef HAS_NORMALMAP\n\n  bool emissiveMapEnabled;\n  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP\n\n  vec2 metallicRoughnessValues;\n  bool metallicRoughnessMapEnabled;\n\n  bool occlusionMapEnabled;\n  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP\n  \n  bool alphaCutoffEnabled;\n  float alphaCutoff; // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  bool IBLenabled;\n  vec2 scaleIBLAmbient; // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  vec4 scaleDiffBaseMR;\n  vec4 scaleFGDSpec;\n  // #endif\n};\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\n#endif\n\n";
export declare const source = "struct PBRFragmentInputs {\n  pbr_vPosition: vec3f,\n  pbr_vUV: vec2f,\n  pbr_vTBN: mat3f,\n  pbr_vNormal: vec3f\n};\n\nvar fragmentInputs: PBRFragmentInputs;\n\nfn pbr_setPositionNormalTangentUV(position: vec4f, normal: vec4f, tangent: vec4f, uv: vec2f)\n{\n  var pos: vec4f = pbrProjection.modelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  let normalW: vec3f = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  let tangentW: vec3f = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  let bitangentW: vec3f = cross(normalW, tangentW) * tangent.w;\n  fragmentInputs,pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  fragmentInputs.pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n\nstruct pbrMaterialUniforms {\n  // Material is unlit\n  unlit: uint32,\n\n  // Base color map\n  baseColorMapEnabled: uint32,\n  baseColorFactor: vec4f,\n\n  normalMapEnabled : uint32,\n  normalScale: f32,  // #ifdef HAS_NORMALMAP\n\n  emissiveMapEnabled: uint32,\n  emissiveFactor: vec3f, // #ifdef HAS_EMISSIVEMAP\n\n  metallicRoughnessValues: vec2f,\n  metallicRoughnessMapEnabled: uint32,\n\n  occlusionMapEnabled: i32,\n  occlusionStrength: f32, // #ifdef HAS_OCCLUSIONMAP\n  \n  alphaCutoffEnabled: i32,\n  alphaCutoff: f32, // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  IBLenabled: i32,\n  scaleIBLAmbient: vec2f, // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  scaleDiffBaseMR: vec4f,\n  scaleFGDSpec: vec4f\n  // #endif\n} \n  \n@binding(2) @group(0) var<uniform> material : pbrMaterialUniforms;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  NdotL: f32,                  // cos angle between normal and light direction\n  NdotV: f32,                  // cos angle between normal and view direction\n  NdotH: f32,                  // cos angle between normal and half vector\n  LdotH: f32,                  // cos angle between light direction and half vector\n  VdotH: f32,                  // cos angle between view direction and half vector\n  perceptualRoughness: f32,    // roughness value, as authored by the model creator (input to shader)\n  metalness: f32,              // metallic value at the surface\n  reflectance0: vec3f,            // full reflectance color (normal incidence angle)\n  reflectance90: vec3f,           // reflectance color at grazing angle\n  alphaRoughness: f32,         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  diffuseColor: vec3f,            // color contribution from diffuse lighting\n  specularColor: vec3f,           // color contribution from specular lighting\n  n: vec3f,                       // normal at surface point\n  v: vec3f,                       // vector from surface point to camera\n};\n\nconst M_PI = 3.141592653589793;\nconst c_MinRoughness = 0.04;\n\nfn SRGBtoLINEAR(srgbIn: vec4f ) -> vec4f\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  var linOut: vec3f = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  var bLess: vec3f = step(vec3(0.04045),srgbIn.xyz);\n  var linOut: vec3f = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4f(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nfn getNormal() -> vec3f\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  var pos_dx: vec3f = dFdx(pbr_vPosition);\n  var pos_dy: vec3f = dFdy(pbr_vPosition);\n  var tex_dx: vec3f = dFdx(vec3(pbr_vUV, 0.0));\n  var tex_dy: vec3f = dFdy(vec3(pbr_vUV, 0.0));\n  var t: vec3f = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  var ng: vec3f = normalize(pbr_vNormal);\n#else\n  var ng: vec3f = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  var b: vec3f = normalize(cross(ng, t));\n  var tbn: mat3f = mat3f(t, b, ng);\n#else // HAS_TANGENTS\n  var tbn: mat3f = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nfn getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection) -> vec3f\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nfn diffuse(pbrInfo: PBRInfo) -> vec3<f32> {\n  return pbrInfo.diffuseColor / PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nfn specularReflection(pbrInfo: PBRInfo) -> vec3<f32> {\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfn geometricOcclusion(pbrInfo: PBRInfo) -> f32 {\n  let NdotL: f32 = pbrInfo.NdotL;\n  let NdotV: f32 = pbrInfo.NdotV;\n  let r: f32 = pbrInfo.alphaRoughness;\n\n  let attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  let attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfn microfacetDistribution(pbrInfo: PBRInfo) -> f32 {\n  let roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  let f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (PI * f * f);\n}\n\nfn PBRInfo_setAmbientLight(pbrInfo: ptr<function, PBRInfo>) {\n  (*pbrInfo).NdotL = 1.0;\n  (*pbrInfo).NdotH = 0.0;\n  (*pbrInfo).LdotH = 0.0;\n  (*pbrInfo).VdotH = 1.0;\n}\n\nfn PBRInfo_setDirectionalLight(pbrInfo: ptr<function, PBRInfo>, lightDirection: vec3<f32>) {\n  let n = (*pbrInfo).n;\n  let v = (*pbrInfo).v;\n  let l = normalize(lightDirection);             // Vector from surface point to light\n  let h = normalize(l + v);                      // Half vector between both l and v\n\n  (*pbrInfo).NdotL = clamp(dot(n, l), 0.001, 1.0);\n  (*pbrInfo).NdotH = clamp(dot(n, h), 0.0, 1.0);\n  (*pbrInfo).LdotH = clamp(dot(l, h), 0.0, 1.0);\n  (*pbrInfo).VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nfn PBRInfo_setPointLight(pbrInfo: ptr<function, PBRInfo>, pointLight: PointLight) {\n  let light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nfn calculateFinalColor(pbrInfo: PBRInfo, lightColor: vec3<f32>) -> vec3<f32> {\n  // Calculate the shading terms for the microfacet specular shading model\n  let F = specularReflection(pbrInfo);\n  let G = geometricOcclusion(pbrInfo);\n  let D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  let diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  let specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nfn pbr_filterColor(colorUnused: vec4<f32>) -> vec4<f32> {\n  // The albedo may be defined from a base texture or a flat color\n  var baseColor: vec4<f32>;\n  #ifdef HAS_BASECOLORMAP\n  baseColor = SRGBtoLINEAR(textureSample(pbr_baseColorSampler, pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;\n  #else\n  baseColor = pbrMaterial.baseColorFactor;\n  #endif\n\n  #ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n  #endif\n\n  var color = vec3<f32>(0.0, 0.0, 0.0);\n\n  if (pbrMaterial.unlit) {\n    color = baseColor.rgb;\n  } else {\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    var perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    var metallic = pbrMaterial.metallicRoughnessValues.x;\n    #ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    let mrSample = textureSample(pbr_metallicRoughnessSampler, pbr_metallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n    #endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    let alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    let f0 = vec3<f32>(0.04);\n    var diffuseColor = baseColor.rgb * (vec3<f32>(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    let specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflectance to 0%.\n    let reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    let specularEnvironmentR0 = specularColor;\n    let specularEnvironmentR90 = vec3<f32>(1.0, 1.0, 1.0) * reflectance90;\n\n    let n = getNormal();                          // normal at surface point\n    let v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera\n\n    let NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    let reflection = -normalize(reflect(v, n));\n\n    var pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n    #ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(&pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for (var i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(&pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for (var i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(&pbrInfo, lighting_getPointLight(i));\n        let attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n    #endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n    #ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n    #endif\n\n    // Apply optional PBR terms for additional (optional) shading\n    #ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      let ao = textureSample(pbr_occlusionSampler, pbr_occlusionSampler, pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n    #endif\n\n    #ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      let emissive = SRGBtoLINEAR(textureSample(pbr_emissiveSampler, pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n    #endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n    #ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3<f32>(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3<f32>(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n    #endif\n  }\n\n  return vec4<f32>(pow(color, vec3<f32>(1.0 / 2.2)), baseColor.a);\n}\n";
//# sourceMappingURL=pbr-material-wgsl.d.ts.map