{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/stats-manager.ts", "../src/utils/log.ts", "../src/utils/uid.ts", "../src/adapter/resources/resource.ts", "../src/adapter/resources/buffer.ts", "../src/shadertypes/data-types/decode-data-types.ts", "../src/shadertypes/vertex-arrays/decode-vertex-format.ts", "../src/shadertypes/textures/texture-format-table.ts", "../src/shadertypes/textures/texture-format-decoder.ts", "../src/image-utils/image-types.ts", "../src/adapter/device.ts", "../src/adapter/luma.ts", "../src/adapter/adapter.ts", "../src/adapter/canvas-context.ts", "../src/utils/promise-utils.ts", "../src/adapter/resources/sampler.ts", "../src/adapter/resources/texture.ts", "../src/adapter/resources/texture-view.ts", "../src/adapter/resources/external-texture.ts", "../src/adapter-utils/format-compiler-log.ts", "../src/adapter/resources/shader.ts", "../src/adapter/resources/framebuffer.ts", "../src/adapter/resources/render-pipeline.ts", "../src/adapter/resources/render-pass.ts", "../src/adapter/resources/compute-pipeline.ts", "../src/adapter/resources/compute-pass.ts", "../src/adapter/resources/command-encoder.ts", "../src/adapter/resources/command-buffer.ts", "../src/shadertypes/data-types/decode-shader-types.ts", "../src/adapter-utils/get-attribute-from-layouts.ts", "../src/adapter/resources/vertex-array.ts", "../src/adapter/resources/transform-feedback.ts", "../src/adapter/resources/query-set.ts", "../src/adapter/resources/pipeline-layout.ts", "../src/utils/array-utils-flat.ts", "../src/utils/is-array.ts", "../src/portable/uniform-buffer-layout.ts", "../src/utils/array-equal.ts", "../src/portable/uniform-block.ts", "../src/portable/uniform-store.ts", "../src/shadertypes/textures/pixel-utils.ts"],
  "sourcesContent": ["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// MAIN API ACCESS POINT\nexport type {AttachDeviceProps, CreateDeviceProps} from './adapter/luma';\nexport {luma} from './adapter/luma';\n\n// ADAPTER (DEVICE AND GPU RESOURCE INTERFACES)\nexport {Adapter} from './adapter/adapter';\n\nexport type {\n  DeviceProps,\n  DeviceInfo,\n  DeviceFeature,\n  DeviceTextureFormatCapabilities\n} from './adapter/device';\nexport {Device, DeviceFeatures, DeviceLimits} from './adapter/device';\n\nexport type {CanvasContextProps} from './adapter/canvas-context';\nexport {CanvasContext} from './adapter/canvas-context';\n\n// GPU RESOURCES\nexport {Resource, type ResourceProps} from './adapter/resources/resource';\n\nexport {Buffer, type BufferProps, type BufferMapCallback} from './adapter/resources/buffer';\n\nexport {Texture, type TextureProps} from './adapter/resources/texture';\n\nexport {TextureView, type TextureViewProps} from './adapter/resources/texture-view';\n\nexport type {ExternalTextureProps} from './adapter/resources/external-texture';\nexport {ExternalTexture} from './adapter/resources/external-texture';\n\nexport type {ShaderProps} from './adapter/resources/shader';\nexport {Shader} from './adapter/resources/shader';\n\nexport type {SamplerProps, SamplerParameters} from './adapter/resources/sampler';\nexport {Sampler} from './adapter/resources/sampler';\n\nexport type {FramebufferProps} from './adapter/resources/framebuffer';\nexport {Framebuffer} from './adapter/resources/framebuffer';\n\nexport type {RenderPipelineProps} from './adapter/resources/render-pipeline';\nexport {RenderPipeline} from './adapter/resources/render-pipeline';\n\nexport type {RenderPassProps} from './adapter/resources/render-pass';\nexport {RenderPass} from './adapter/resources/render-pass';\n\nexport type {ComputePipelineProps} from './adapter/resources/compute-pipeline';\nexport {ComputePipeline} from './adapter/resources/compute-pipeline';\n\nexport type {ComputePassProps} from './adapter/resources/compute-pass';\nexport {ComputePass} from './adapter/resources/compute-pass';\n\nexport type {CommandEncoderProps} from './adapter/resources/command-encoder';\nexport {CommandEncoder} from './adapter/resources/command-encoder';\n\nexport type {CommandBufferProps} from './adapter/resources/command-buffer';\nexport {CommandBuffer} from './adapter/resources/command-buffer';\n\nexport type {VertexArrayProps} from './adapter/resources/vertex-array';\nexport {VertexArray} from './adapter/resources/vertex-array';\n\nexport type {TransformFeedbackProps, BufferRange} from './adapter/resources/transform-feedback';\nexport {TransformFeedback} from './adapter/resources/transform-feedback';\n\nexport type {QuerySetProps} from './adapter/resources/query-set';\nexport {QuerySet} from './adapter/resources/query-set';\n\nexport type {PipelineLayoutProps} from './adapter/resources/pipeline-layout';\nexport {PipelineLayout} from './adapter/resources/pipeline-layout';\n\n// PORTABLE API - UNIFORM BUFFERS\nexport {UniformBufferLayout} from './portable/uniform-buffer-layout';\nexport {UniformBlock} from './portable/uniform-block';\nexport {UniformStore} from './portable/uniform-store';\n// TEXTURE TYPES\n\n// API TYPES\nexport type {CompilerMessage} from './adapter/types/compiler-message';\n\nexport type {ExternalImage} from './image-utils/image-types';\n\nexport {\n  type CopyExternalImageOptions,\n  type CopyImageDataOptions\n} from './adapter/resources/texture';\n\nexport type {Parameters, PrimitiveTopology, IndexFormat} from './adapter/types/parameters';\n\nexport type {\n  CullMode,\n  FrontFace,\n  RasterizationParameters,\n  CompareFunction,\n  StencilOperation,\n  DepthStencilParameters,\n  BlendFactor,\n  BlendOperation,\n  ColorParameters,\n  MultisampleParameters,\n  RenderPassParameters,\n  RenderPipelineParameters,\n  PolygonMode,\n  ProvokingVertex\n} from './adapter/types/parameters';\n\nexport type {ColorAttachment, DepthStencilAttachment} from './adapter/types/attachments';\n\nexport type {\n  ShaderLayout,\n  ComputeShaderLayout,\n  AttributeDeclaration,\n  BindingDeclaration,\n  Binding,\n  UniformBufferBindingLayout,\n  StorageBufferBindingLayout,\n  TextureBindingLayout,\n  SamplerBindingLayout,\n  StorageTextureBindingLayout\n} from './adapter/types/shader-layout';\nexport type {BufferLayout, BufferAttributeLayout} from './adapter/types/buffer-layout';\nexport type {\n  // Deprecated, todo\n  AttributeBinding,\n  UniformBinding,\n  UniformBlockBinding,\n  VaryingBinding\n} from './adapter/types/shader-layout';\n\nexport type {UniformValue} from './adapter/types/uniforms';\n\n// TYPED ARRAY TYPES\n\nexport type {\n  NumberArray,\n  TypedArray,\n  TypedArrayConstructor,\n  BigTypedArray,\n  BigTypedArrayConstructor\n} from './types';\n\n// GPU TYPE UTILS - BASIC DATA TYPES\n\nexport {\n  type PrimitiveDataType,\n  type SignedDataType,\n  type NormalizedDataType,\n  type DataTypeInfo,\n  type DataTypeArray,\n  type NormalizedDataTypeArray\n} from './shadertypes/data-types/data-types';\nexport {\n  type AttributeShaderType,\n  type VariableShaderType\n} from './shadertypes/data-types/shader-types';\nexport {\n  getDataTypeInfo,\n  getDataType,\n  getTypedArrayConstructor,\n  getNormalizedDataType\n} from './shadertypes/data-types/decode-data-types';\nexport {\n  getVariableShaderTypeInfo,\n  getAttributeShaderTypeInfo\n} from './shadertypes/data-types/decode-shader-types';\n\n// GPU TYPE UTILS - VERTEX ARRAYs\n\nexport {type VertexFormat} from './shadertypes/vertex-arrays/vertex-formats';\n\nexport {\n  getVertexFormatInfo,\n  getVertexFormatFromAttribute,\n  makeVertexFormat\n} from './shadertypes/vertex-arrays/decode-vertex-format';\n\n// GPU TYPE UTILS - Texture Formats\n\nexport {\n  type TextureFormat,\n  type TextureFormatColor,\n  type TextureFormatDepthStencil,\n  type TextureCompression,\n  type TextureFormatInfo,\n  type TextureFormatCapabilities\n} from './shadertypes/textures/texture-formats';\n\nexport {\n  TextureFormatDecoder,\n  textureFormatDecoder\n} from './shadertypes/textures/texture-format-decoder';\n\nexport {type PixelData, readPixel, writePixel} from './shadertypes/textures/pixel-utils';\n\n// GENERAL EXPORTS - FOR APPLICATIONS\n\nexport type {StatsManager} from './utils/stats-manager'; // TODO - should this be moved to probe.gl?\n\n// ADAPTER UTILS - for implementing Device adapters (@luma.gl/webgl and @luma.gl/webgpu)\n\nexport type {\n  CopyBufferToBufferOptions,\n  CopyBufferToTextureOptions,\n  CopyTextureToBufferOptions,\n  CopyTextureToTextureOptions\n} from './adapter/resources/command-encoder';\n\n// INTERNAL UTILS - for use in other luma.gl modules only\nexport {log} from './utils/log';\nexport {getScratchArray} from './utils/array-utils-flat';\nexport type {AttributeInfo} from './adapter-utils/get-attribute-from-layouts';\nexport {getAttributeInfosFromLayouts} from './adapter-utils/get-attribute-from-layouts';\n\n// TEST EXPORTS\nexport {\n  getTextureFormatDefinition as _getTextureFormatDefinition,\n  getTextureFormatTable as _getTextureFormatTable\n} from './shadertypes/textures/texture-format-table';\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Stats} from '@probe.gl/stats';\n\n/**\n * Helper class managing a collection of probe.gl stats objects\n */\nexport class StatsManager {\n  stats = new Map();\n\n  getStats(name: string): Stats {\n    return this.get(name);\n  }\n\n  get(name: string): Stats {\n    if (!this.stats.has(name)) {\n      this.stats.set(name, new Stats({id: name}));\n    }\n\n    return this.stats.get(name);\n  }\n}\n\n/** Global stats for all luma.gl devices */\nexport const lumaStats: StatsManager = new StatsManager();\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Log} from '@probe.gl/log';\n\n/** Global log instance */\nexport const log: Log = new Log({id: 'luma.gl'});\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst uidCounters: Record<string, number> = {};\n\n/**\n * Returns a UID.\n * @param id= - Identifier base name\n * @return uid\n **/\nexport function uid(id: string = 'id'): string {\n  uidCounters[id] = uidCounters[id] || 1;\n  const count = uidCounters[id]++;\n  return `${id}-${count}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {uid} from '../../utils/uid';\n\nexport type ResourceProps = {\n  /** Name of resource, mainly for debugging purposes. A unique name will be assigned if not provided */\n  id?: string;\n  /** Handle for the underlying resources (WebGL object or WebGPU handle) */\n  handle?: any;\n  /** User provided data stored on this resource  */\n  userData?: {[key: string]: any};\n};\n\n/**\n * Base class for GPU (WebGPU/WebGL) Resources\n */\nexport abstract class Resource<Props extends ResourceProps> {\n  /** Default properties for resource */\n  static defaultProps: Required<ResourceProps> = {\n    id: 'undefined',\n    handle: undefined,\n    userData: undefined!\n  };\n\n  abstract get [Symbol.toStringTag](): string;\n\n  toString(): string {\n    return `${this[Symbol.toStringTag] || this.constructor.name}:\"${this.id}\"`;\n  }\n\n  /** props.id, for debugging. */\n  id: string;\n  readonly props: Required<Props>;\n  readonly userData: Record<string, unknown> = {};\n  abstract readonly device: Device;\n  abstract readonly handle: unknown;\n  private _device: Device;\n\n  /** Whether this resource has been destroyed */\n  destroyed: boolean = false;\n  /** For resources that allocate GPU memory */\n  private allocatedBytes: number = 0;\n  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created \"sub\" resources. */\n  private _attachedResources = new Set<Resource<ResourceProps>>();\n\n  /**\n   * Create a new Resource. Called from Subclass\n   */\n  constructor(device: Device, props: Props, defaultProps: Required<Props>) {\n    if (!device) {\n      throw new Error('no device');\n    }\n    this._device = device;\n    this.props = selectivelyMerge<Props>(props, defaultProps);\n\n    const id =\n      this.props.id !== 'undefined' ? (this.props.id as string) : uid(this[Symbol.toStringTag]);\n    this.props.id = id;\n    this.id = id;\n    this.userData = this.props.userData || {};\n\n    this.addStats();\n  }\n\n  /**\n   * destroy can be called on any resource to release it before it is garbage collected.\n   */\n  destroy(): void {\n    this.destroyResource();\n  }\n\n  /** @deprecated Use destroy() */\n  delete(): this {\n    this.destroy();\n    return this;\n  }\n\n  /**\n   * Combines a map of user props and default props, only including props from defaultProps\n   * @returns returns a map of overridden default props\n   */\n  getProps(): object {\n    return this.props;\n  }\n\n  // ATTACHED RESOURCES\n\n  /**\n   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed\n   * Called automatically when sub resources are auto created but can be called by application\n   */\n  attachResource(resource: Resource<ResourceProps>): void {\n    this._attachedResources.add(resource);\n  }\n\n  /**\n   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.\n   */\n  detachResource(resource: Resource<ResourceProps>): void {\n    this._attachedResources.delete(resource);\n  }\n\n  /**\n   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.\n   */\n  destroyAttachedResource(resource: Resource<ResourceProps>): void {\n    if (this._attachedResources.delete(resource)) {\n      resource.destroy();\n    }\n  }\n\n  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */\n  destroyAttachedResources(): void {\n    for (const resource of Object.values(this._attachedResources)) {\n      resource.destroy();\n    }\n    // don't remove while we are iterating\n    this._attachedResources = new Set<Resource<ResourceProps>>();\n  }\n\n  // PROTECTED METHODS\n\n  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */\n  protected destroyResource(): void {\n    this.destroyAttachedResources();\n    this.removeStats();\n    this.destroyed = true;\n  }\n\n  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */\n  protected removeStats(): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get(`${name}s Active`).decrementCount();\n  }\n\n  /** Called by subclass to track memory allocations */\n  protected trackAllocatedMemory(bytes: number, name = this[Symbol.toStringTag]): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').addCount(bytes);\n    stats.get(`${name} Memory`).addCount(bytes);\n    this.allocatedBytes = bytes;\n  }\n\n  /** Called by subclass to track memory deallocations */\n  protected trackDeallocatedMemory(name = this[Symbol.toStringTag]): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').subtractCount(this.allocatedBytes);\n    stats.get(`${name} Memory`).subtractCount(this.allocatedBytes);\n    this.allocatedBytes = 0;\n  }\n\n  /** Called by resource constructor to track object creation */\n  private addStats(): void {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get('Resources Created').incrementCount();\n    stats.get(`${name}s Created`).incrementCount();\n    stats.get(`${name}s Active`).incrementCount();\n  }\n}\n\n/**\n * Combines a map of user props and default props, only including props from defaultProps\n * @param props\n * @param defaultProps\n * @returns returns a map of overridden default props\n */\nfunction selectivelyMerge<Props>(props: Props, defaultProps: Required<Props>): Required<Props> {\n  const mergedProps = {...defaultProps};\n  for (const key in props) {\n    if (props[key] !== undefined) {\n      mergedProps[key] = props[key];\n    }\n  }\n  return mergedProps;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\n/** Callback for Buffer.mapAndReadAsync */\nexport type BufferMapCallback<T> = (arrayBuffer: ArrayBuffer, lifetime: 'mapped' | 'copied') => T;\n\nexport type BufferProps = ResourceProps & {\n  /** Supply a handle to connect to an existing device-specific buffer */\n  handle?: WebGLBuffer;\n  /** Specifies how this buffer can be used */\n  usage?: number;\n  /** Length in bytes of memory to be allocated. If not specified, `byteLength` of  `props.data` will be used. */\n  byteLength?: number;\n  /** Byte offset into the newly created Buffer to store data at */\n  byteOffset?: number;\n  /** If props.usage includes Buffer.INDEX */\n  indexType?: 'uint16' | 'uint32';\n  /** Data to initialize the buffer with. */\n  data?: ArrayBuffer | ArrayBufferView | null;\n  /** Callback to initialize data without copy */\n  onMapped?: BufferMapCallback<void>;\n};\n\n/** Abstract GPU buffer */\nexport abstract class Buffer extends Resource<BufferProps> {\n  /** Index buffer */\n  static INDEX = 0x0010;\n  /** Vertex buffer */\n  static VERTEX = 0x0020;\n  /** Uniform buffer */\n  static UNIFORM = 0x0040;\n  /** Storage buffer */\n  static STORAGE = 0x0080;\n  static INDIRECT = 0x0100;\n  static QUERY_RESOLVE = 0x0200;\n\n  // Usage Flags\n  static MAP_READ = 0x01;\n  static MAP_WRITE = 0x02;\n  static COPY_SRC = 0x0004;\n  static COPY_DST = 0x0008;\n\n  override get [Symbol.toStringTag](): string {\n    return 'Buffer';\n  }\n\n  /** The usage with which this buffer was created */\n  readonly usage: number;\n  /** For index buffers, whether indices are 16 or 32 bit */\n  readonly indexType?: 'uint16' | 'uint32';\n  /** Length of buffer in bytes */\n  abstract byteLength: number;\n  /** \"Time\" of last update, can be used to check if redraw is needed */\n  updateTimestamp: number;\n\n  constructor(device: Device, props: BufferProps) {\n    const deducedProps = {...props};\n\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        deducedProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        deducedProps.indexType = 'uint16';\n      }\n    }\n\n    // Remove data from props before storing, we don't want to hold on to a big chunk of memory\n    delete deducedProps.data;\n\n    super(device, deducedProps, Buffer.defaultProps);\n\n    this.usage = deducedProps.usage || 0;\n    this.indexType = deducedProps.indexType;\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /**\n   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.\n   * @note Does not copy contents of the cloned Buffer.\n   */\n  clone(props: {byteLength: number}): Buffer {\n    return this.device.createBuffer({...this.props, ...props});\n  }\n\n  /** Write data to buffer */\n  abstract write(\n    data: ArrayBufferLike | ArrayBufferView | SharedArrayBuffer,\n    byteOffset?: number\n  ): void;\n\n  abstract mapAndWriteAsync(\n    onMapped: BufferMapCallback<void | Promise<void>>,\n    byteOffset?: number,\n    byteLength?: number\n  ): Promise<void>;\n\n  /** Reads data asynchronously, returns a copy of the buffer data */\n  abstract readAsync(byteOffset?: number, byteLength?: number): Promise<Uint8Array>;\n\n  /** Maps buffer data to CPU memory. Mapped memory is only accessible in the callback */\n  abstract mapAndReadAsync<T>(\n    onMapped: BufferMapCallback<T>,\n    byteOffset?: number,\n    byteLength?: number\n  ): Promise<T>;\n\n  /** Read data synchronously. @note WebGL2 only */\n  abstract readSyncWebGL(byteOffset?: number, byteLength?: number): Uint8Array;\n\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n\n  /** Max amount of debug data saved. Two vec4's */\n  static DEBUG_DATA_MAX_LENGTH = 32;\n\n  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */\n  debugData: ArrayBuffer = new ArrayBuffer(0);\n\n  /** This doesn't handle partial non-zero offset updates correctly */\n  protected _setDebugData(\n    data: ArrayBufferView | ArrayBufferLike | null,\n    byteOffset: number,\n    byteLength: number\n  ): void {\n    const arrayBuffer: ArrayBufferLike | null = ArrayBuffer.isView(data) ? data.buffer : data;\n    const debugDataLength = Math.min(\n      data ? data.byteLength : byteLength,\n      Buffer.DEBUG_DATA_MAX_LENGTH\n    );\n    if (arrayBuffer === null) {\n      this.debugData = new ArrayBuffer(debugDataLength);\n    } else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) {\n      this.debugData = arrayBuffer.slice(0, debugDataLength);\n    } else {\n      this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);\n    }\n  }\n\n  static override defaultProps: Required<BufferProps> = {\n    ...Resource.defaultProps,\n    usage: 0, // Buffer.COPY_DST | Buffer.COPY_SRC\n    byteLength: 0,\n    byteOffset: 0,\n    data: null,\n    indexType: 'uint16',\n    onMapped: undefined!\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TypedArray, TypedArrayConstructor} from '../../types';\nimport {PrimitiveDataType, SignedDataType, NormalizedDataType, DataTypeInfo} from './data-types';\n\n/**\n * Gets info about a data type constant (signed or normalized)\n * @returns underlying primitive / signed types, byte length, normalization, integer, signed flags\n */\nexport function getDataTypeInfo(type: NormalizedDataType): DataTypeInfo {\n  const [signedType, primitiveType, byteLength] = NORMALIZED_TYPE_MAP[type];\n  const normalized: boolean = type.includes('norm');\n  const integer: boolean = !normalized && !type.startsWith('float');\n  const signed: boolean = type.startsWith('s');\n  return {\n    signedType,\n    primitiveType,\n    byteLength,\n    normalized,\n    integer,\n    signed\n  };\n}\n\n/** Build a vertex format from a signed data type and a component */\nexport function getNormalizedDataType(signedDataType: SignedDataType): NormalizedDataType {\n  const dataType: NormalizedDataType = signedDataType;\n  // prettier-ignore\n  switch (dataType) {\n    case 'uint8': return 'unorm8';\n    case 'sint8': return 'snorm8';\n    case 'uint16': return 'unorm16';\n    case 'sint16': return 'snorm16';\n    default: return dataType;\n  }\n}\n\n/** Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes) */\nexport function alignTo(size: number, count: number): number {\n  // prettier-ignore\n  switch (count) {\n    case 1: return size; // Pad upwards to even multiple of 2\n    case 2: return size + (size % 2); // Pad upwards to even multiple of 2\n    default: return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4\n  }\n}\n\n/** Returns the VariableShaderType that corresponds to a typed array */\nexport function getDataType(arrayOrType: TypedArray | TypedArrayConstructor): SignedDataType {\n  const Constructor = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  if (Constructor === Uint8ClampedArray) {\n    return 'uint8';\n  }\n  const info = Object.values(NORMALIZED_TYPE_MAP).find(entry => Constructor === entry[4]);\n  if (!info) {\n    throw new Error(Constructor.name);\n  }\n  return info[0];\n}\n\n/** Returns the TypedArray that corresponds to a shader data type */\nexport function getTypedArrayConstructor(type: NormalizedDataType): TypedArrayConstructor {\n  const [, , , , Constructor] = NORMALIZED_TYPE_MAP[type];\n  return Constructor;\n}\n\nconst NORMALIZED_TYPE_MAP: Record<\n  NormalizedDataType,\n  [\n    SignedDataType,\n    PrimitiveDataType,\n    bytes: 1 | 2 | 4,\n    normalized: boolean,\n    arrayConstructor: TypedArrayConstructor\n  ]\n> = {\n  uint8: ['uint8', 'u32', 1, false, Uint8Array],\n  sint8: ['sint8', 'i32', 1, false, Int8Array],\n  unorm8: ['uint8', 'f32', 1, true, Uint8Array],\n  snorm8: ['sint8', 'f32', 1, true, Int8Array],\n  uint16: ['uint16', 'u32', 2, false, Uint16Array],\n  sint16: ['sint16', 'i32', 2, false, Int16Array],\n  unorm16: ['uint16', 'u32', 2, true, Uint16Array],\n  snorm16: ['sint16', 'i32', 2, true, Int16Array],\n  float16: ['float16', 'f16', 2, false, Uint16Array],\n  float32: ['float32', 'f32', 4, false, Float32Array],\n  uint32: ['uint32', 'u32', 4, false, Uint32Array],\n  sint32: ['sint32', 'i32', 4, false, Int32Array]\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '../../types';\nimport type {NormalizedDataType, PrimitiveDataType, SignedDataType} from '../data-types/data-types';\nimport type {VertexFormat, VertexFormatInfo} from './vertex-formats';\nimport {getDataTypeInfo, getDataType, getNormalizedDataType} from '../data-types/decode-data-types';\n\n/**\n * Decodes a vertex format, returning type, components, byte  length and flags (integer, signed, normalized)\n */\nexport function getVertexFormatInfo(format: VertexFormat): VertexFormatInfo {\n  // Strip the -webgl ending if present\n  let webglOnly: boolean | undefined;\n  if (format.endsWith('-webgl')) {\n    format.replace('-webgl', '');\n    webglOnly = true;\n  }\n  // split components from type\n  const [type_, count] = format.split('x');\n  const type = type_ as NormalizedDataType;\n  const components = (count ? parseInt(count) : 1) as 1 | 2 | 3 | 4;\n  // decode the type\n  const decodedType = getDataTypeInfo(type);\n  const result: VertexFormatInfo = {\n    type,\n    components,\n    byteLength: decodedType.byteLength * components,\n    integer: decodedType.integer,\n    signed: decodedType.signed,\n    normalized: decodedType.normalized\n  };\n  if (webglOnly) {\n    result.webglOnly = true;\n  }\n  return result;\n}\n\n/** Build a vertex format from a signed data type and a component */\nexport function makeVertexFormat(\n  signedDataType: SignedDataType,\n  components: 1 | 2 | 3 | 4,\n  normalized?: boolean\n): VertexFormat {\n  const dataType: NormalizedDataType = normalized\n    ? getNormalizedDataType(signedDataType)\n    : signedDataType;\n\n  switch (dataType) {\n    // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below\n    case 'unorm8':\n      if (components === 1) {\n        return 'unorm8';\n      }\n      if (components === 3) {\n        return 'unorm8x3-webgl';\n      }\n      return `${dataType}x${components}`;\n\n    case 'snorm8':\n    case 'uint8':\n    case 'sint8':\n    // WebGPU 8 bit formats must be aligned to 16 bit boundaries');\n    // fall through\n    case 'uint16':\n    case 'sint16':\n    case 'unorm16':\n    case 'snorm16':\n    case 'float16':\n      // WebGPU 16 bit formats must be aligned to 32 bit boundaries\n      if (components === 1 || components === 3) {\n        throw new Error(`size: ${components}`);\n      }\n      return `${dataType}x${components}`;\n\n    default:\n      return components === 1 ? dataType : `${dataType}x${components}`;\n  }\n}\n\n/** Get the vertex format for an attribute with TypedArray and size */\nexport function getVertexFormatFromAttribute(\n  typedArray: TypedArray,\n  size: number,\n  normalized?: boolean\n): VertexFormat {\n  if (!size || size > 4) {\n    throw new Error(`size ${size}`);\n  }\n\n  const components = size as 1 | 2 | 3 | 4;\n  const signedDataType = getDataType(typedArray);\n  return makeVertexFormat(signedDataType, components, normalized);\n}\n\n/** Return a \"default\" vertex format for a certain shader data type\n The simplest vertex format that matches the shader attribute's data type */\n\nexport function getCompatibleVertexFormat(opts: {\n  primitiveType: PrimitiveDataType;\n  components: 1 | 2 | 3 | 4;\n}): VertexFormat {\n  let vertexType: NormalizedDataType;\n  switch (opts.primitiveType) {\n    case 'f32':\n      vertexType = 'float32';\n      break;\n    case 'i32':\n      vertexType = 'sint32';\n      break;\n    case 'u32':\n      vertexType = 'uint32';\n      break;\n    case 'f16':\n      return opts.components <= 2 ? 'float16x2' : 'float16x4';\n  }\n\n  // TODO logic does not work for float16\n  if (opts.components === 1) {\n    return vertexType;\n  }\n  return `${vertexType}x${opts.components}`;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  TextureFormat,\n  TextureFormatColorUncompressed,\n  TextureFormatDepthStencil,\n  TextureFeature,\n  TextureFormatInfo,\n  TextureFormatCompressed\n} from './texture-formats';\n/* eslint-disable camelcase */\n\n// Define local device feature strings to optimize minification\nconst texture_compression_bc: TextureFeature = 'texture-compression-bc';\nconst texture_compression_astc: TextureFeature = 'texture-compression-astc';\nconst texture_compression_etc2: TextureFeature = 'texture-compression-etc2';\nconst texture_compression_etc1_webgl: TextureFeature = 'texture-compression-etc1-webgl';\nconst texture_compression_pvrtc_webgl: TextureFeature = 'texture-compression-pvrtc-webgl';\nconst texture_compression_atc_webgl: TextureFeature = 'texture-compression-atc-webgl';\n\nconst float32_renderable: TextureFeature = 'float32-renderable-webgl';\nconst float16_renderable: TextureFeature = 'float16-renderable-webgl';\nconst rgb9e5ufloat_renderable: TextureFeature = 'rgb9e5ufloat-renderable-webgl';\nconst snorm8_renderable: TextureFeature = 'snorm8-renderable-webgl';\nconst norm16_renderable: TextureFeature = 'norm16-renderable-webgl';\nconst snorm16_renderable: TextureFeature = 'snorm16-renderable-webgl';\n\nconst float32_filterable: TextureFeature = 'float32-filterable';\nconst float16_filterable: TextureFeature = 'float16-filterable-webgl';\n\n/** https://www.w3.org/TR/webgpu/#texture-format-caps */\n\n/** Internal type representing texture capabilities */\ntype TextureFormatDefinition = Partial<TextureFormatInfo> & {\n  /** for compressed texture formats */\n  f?: TextureFeature;\n  /** renderable if feature is present. false means the spec does not support this format */\n  render?: TextureFeature | false;\n  /** filterable if feature is present. false means the spec does not support this format */\n  filter?: TextureFeature | false;\n  blend?: TextureFeature | false;\n  store?: TextureFeature | false;\n\n  /** (bytes per pixel), for memory usage calculations. */\n  b?: number;\n  /** channels */\n  c?: number;\n  bpp?: number;\n  /** packed */\n  p?: number;\n\n  /** If not supported on WebGPU */\n  wgpu?: false;\n};\n\nexport function getTextureFormatDefinition(format: TextureFormat): TextureFormatDefinition {\n  const info = TEXTURE_FORMAT_TABLE[format];\n  if (!info) {\n    throw new Error(`Unsupported texture format ${format}`);\n  }\n  return info;\n}\n\nexport function getTextureFormatTable(): Readonly<Record<TextureFormat, TextureFormatDefinition>> {\n  return TEXTURE_FORMAT_TABLE;\n}\n\n// prettier-ignore\nconst TEXTURE_FORMAT_COLOR_DEPTH_TABLE: Readonly<Record<TextureFormatColorUncompressed | TextureFormatDepthStencil, TextureFormatDefinition>> = {\n  // 8-bit formats\n  'r8unorm': {},\n  'rg8unorm': {},\n  'rgb8unorm-webgl': {},\n  'rgba8unorm': {},\n  'rgba8unorm-srgb': {},\n\n  'r8snorm': {render: snorm8_renderable},\n  'rg8snorm': {render: snorm8_renderable},\n  'rgb8snorm-webgl': {},\n  'rgba8snorm': {render: snorm8_renderable},\n\n  'r8uint': {},\n  'rg8uint': {},\n  'rgba8uint': {},\n\n  'r8sint': {},\n  'rg8sint': {},\n  'rgba8sint': {},\n\n  'bgra8unorm': {},\n  'bgra8unorm-srgb': {},\n\n\n  'r16unorm': {f: norm16_renderable},\n  'rg16unorm': {render: norm16_renderable},\n  'rgb16unorm-webgl': {f: norm16_renderable}, // rgb not renderable\n  'rgba16unorm': {render: norm16_renderable},\n\n  'r16snorm': {f: snorm16_renderable},\n  'rg16snorm': {render: snorm16_renderable},\n  'rgb16snorm-webgl': {f: norm16_renderable}, // rgb not renderable\n  'rgba16snorm': {render: snorm16_renderable},\n\n  'r16uint': {},\n  'rg16uint': {},\n  'rgba16uint': {},\n\n  'r16sint': {},\n  'rg16sint': {},\n  'rgba16sint': {},\n\n  'r16float': {render: float16_renderable, filter: 'float16-filterable-webgl'},\n  'rg16float': {render: float16_renderable, filter: float16_filterable},\n  'rgba16float': {render: float16_renderable, filter: float16_filterable},\n\n  'r32uint': {},\n  'rg32uint': {},\n  'rgba32uint': {},\n\n  'r32sint': {},\n  'rg32sint': {},\n  'rgba32sint': {},\n\n  'r32float': {render: float32_renderable, filter: float32_filterable},\n  'rg32float': {render: false, filter: float32_filterable},\n  'rgb32float-webgl': {render: float32_renderable, filter: float32_filterable},\n  'rgba32float': {render: float32_renderable, filter: float32_filterable},\n\n  // Packed 16-bit formats\n  'rgba4unorm-webgl': {channels: 'rgba', bitsPerChannel: [4, 4, 4, 4], packed: true},\n  'rgb565unorm-webgl': {channels: 'rgb', bitsPerChannel: [5, 6, 5, 0], packed: true},\n  'rgb5a1unorm-webgl': {channels: 'rgba', bitsPerChannel: [5, 5, 5, 1], packed: true},\n\n  // Packed 32 bit formats\n  'rgb9e5ufloat': {channels: 'rgb', packed: true, render: rgb9e5ufloat_renderable}, // , filter: true},\n  'rg11b10ufloat': {channels: 'rgb', bitsPerChannel: [11, 11, 10, 0], packed: true, p: 1,render: float32_renderable},\n  'rgb10a2unorm': {channels: 'rgba',  bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1},\n  'rgb10a2uint': {channels: 'rgba',  bitsPerChannel: [10, 10, 10, 2], packed: true, p: 1},\n\n  // Depth/stencil Formats\n  \n  // Depth and stencil formats\n  stencil8: {attachment: 'stencil', bitsPerChannel: [8, 0, 0, 0], dataType: 'uint8'},\n  'depth16unorm': {attachment: 'depth',  bitsPerChannel: [16, 0, 0, 0], dataType: 'uint16'},\n  'depth24plus': {attachment: 'depth', bitsPerChannel: [24, 0, 0, 0], dataType: 'uint32'},\n  'depth32float': {attachment: 'depth', bitsPerChannel: [32, 0, 0, 0], dataType: 'float32'},\n  // The depth component of the \"depth24plus\" and \"depth24plus-stencil8\" formats may be implemented as either a 24-bit depth value or a \"depth32float\" value.\n  'depth24plus-stencil8': {attachment: 'depth-stencil', bitsPerChannel: [24, 8, 0, 0], packed: true},\n  // \"depth32float-stencil8\" feature\n  'depth32float-stencil8': {attachment: 'depth-stencil', bitsPerChannel: [32, 8, 0, 0], packed: true},\n};\n\n// prettier-ignore\nconst TEXTURE_FORMAT_COMPRESSED_TABLE: Readonly<Record<TextureFormatCompressed, TextureFormatDefinition>> = {\n\n  // BC compressed formats: check device.features.has(\"texture-compression-bc\");\n\n  'bc1-rgb-unorm-webgl': {f: texture_compression_bc},\n  'bc1-rgb-unorm-srgb-webgl': {f: texture_compression_bc},\n\n  'bc1-rgba-unorm': {f: texture_compression_bc},\n  'bc1-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc2-rgba-unorm': {f: texture_compression_bc},\n  'bc2-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc3-rgba-unorm': {f: texture_compression_bc},\n  'bc3-rgba-unorm-srgb': {f: texture_compression_bc},\n  'bc4-r-unorm': {f: texture_compression_bc},\n  'bc4-r-snorm': {f: texture_compression_bc},\n  'bc5-rg-unorm': {f: texture_compression_bc},\n  'bc5-rg-snorm': {f: texture_compression_bc},\n  'bc6h-rgb-ufloat': {f: texture_compression_bc},\n  'bc6h-rgb-float': {f: texture_compression_bc},\n  'bc7-rgba-unorm': {f: texture_compression_bc},\n  'bc7-rgba-unorm-srgb': {f: texture_compression_bc},\n\n  // WEBGL_compressed_texture_etc: device.features.has(\"texture-compression-etc2\")\n  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression\n\n  'etc2-rgb8unorm': {f: texture_compression_etc2},\n  'etc2-rgb8unorm-srgb': {f: texture_compression_etc2},\n  'etc2-rgb8a1unorm': {f: texture_compression_etc2},\n  'etc2-rgb8a1unorm-srgb': {f: texture_compression_etc2},\n  'etc2-rgba8unorm': {f: texture_compression_etc2},\n  'etc2-rgba8unorm-srgb': {f: texture_compression_etc2},\n\n  'eac-r11unorm': {f: texture_compression_etc2},\n  'eac-r11snorm': {f: texture_compression_etc2},\n  'eac-rg11unorm': {f: texture_compression_etc2},\n  'eac-rg11snorm': {f: texture_compression_etc2},\n\n  // X_ASTC compressed formats: device.features.has(\"texture-compression-astc\")\n\n  'astc-4x4-unorm': {f: texture_compression_astc},\n  'astc-4x4-unorm-srgb': {f: texture_compression_astc},\n  'astc-5x4-unorm': {f: texture_compression_astc},\n  'astc-5x4-unorm-srgb': {f: texture_compression_astc},\n  'astc-5x5-unorm': {f: texture_compression_astc},\n  'astc-5x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-6x5-unorm': {f: texture_compression_astc},\n  'astc-6x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-6x6-unorm': {f: texture_compression_astc},\n  'astc-6x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x5-unorm': {f: texture_compression_astc},\n  'astc-8x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x6-unorm': {f: texture_compression_astc},\n  'astc-8x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-8x8-unorm': {f: texture_compression_astc},\n  'astc-8x8-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x5-unorm': {f: texture_compression_astc},\n  'astc-10x5-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x6-unorm': {f: texture_compression_astc},\n  'astc-10x6-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x8-unorm': {f: texture_compression_astc},\n  'astc-10x8-unorm-srgb': {f: texture_compression_astc},\n  'astc-10x10-unorm': {f: texture_compression_astc},\n  'astc-10x10-unorm-srgb': {f: texture_compression_astc},\n  'astc-12x10-unorm': {f: texture_compression_astc},\n  'astc-12x10-unorm-srgb': {f: texture_compression_astc},\n  'astc-12x12-unorm': {f: texture_compression_astc},\n  'astc-12x12-unorm-srgb': {f: texture_compression_astc},\n\n  // WEBGL_compressed_texture_pvrtc\n\n  'pvrtc-rgb4unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rgba4unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rbg2unorm-webgl': {f: texture_compression_pvrtc_webgl},\n  'pvrtc-rgba2unorm-webgl': {f: texture_compression_pvrtc_webgl},\n\n  // WEBGL_compressed_texture_etc1\n\n  'etc1-rbg-unorm-webgl': {f: texture_compression_etc1_webgl},\n\n  // WEBGL_compressed_texture_atc\n\n  'atc-rgb-unorm-webgl': {f: texture_compression_atc_webgl},\n  'atc-rgba-unorm-webgl': {f: texture_compression_atc_webgl},\n  'atc-rgbai-unorm-webgl': {f: texture_compression_atc_webgl}\n};\n\nexport const TEXTURE_FORMAT_TABLE: Readonly<Record<TextureFormat, TextureFormatDefinition>> = {\n  ...TEXTURE_FORMAT_COLOR_DEPTH_TABLE,\n  ...TEXTURE_FORMAT_COMPRESSED_TABLE\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NormalizedDataType} from '../data-types/data-types';\nimport {getDataTypeInfo} from '../data-types/decode-data-types';\nimport type {\n  TextureFormat,\n  TextureFormatCompressed,\n  TextureFormatInfo,\n  TextureFormatCapabilities,\n  TextureFormatColor\n} from './texture-formats';\nimport {getTextureFormatDefinition} from './texture-format-table';\n\n// prettier-ignore\nconst COMPRESSED_TEXTURE_FORMAT_PREFIXES = [\n  'bc1', 'bc2', 'bc3', 'bc4', 'bc5', 'bc6', 'bc7', 'etc1', 'etc2', 'eac', 'atc', 'astc', 'pvrtc'\n];\n\nconst RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;\n\nexport class TextureFormatDecoder {\n  /** Returns information about a texture format, e.g. attatchment type, components, byte length and flags (integer, signed, normalized) */\n  getInfo(format: TextureFormat): TextureFormatInfo {\n    return getTextureFormatInfo(format);\n  }\n\n  /** Checks if a texture format is color */\n  isColor(format: TextureFormat): format is TextureFormatColor {\n    return format.startsWith('rgba') || format.startsWith('bgra') || format.startsWith('rgb');\n  }\n\n  /** Checks if a texture format is depth or stencil */\n  isDepthStencil(format: TextureFormat): boolean {\n    return format.startsWith('depth') || format.startsWith('stencil');\n  }\n\n  /** Checks if a texture format is compressed */\n  isCompressed(format: TextureFormat): format is TextureFormatCompressed {\n    return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some(prefix => (format as string).startsWith(prefix));\n  }\n\n  /**\n   * Returns the \"static\" capabilities of a texture format.\n   * @note Needs to be checked against current device\n   */\n  getCapabilities(format: TextureFormat): TextureFormatCapabilities {\n    const info = getTextureFormatDefinition(format);\n\n    const formatCapabilities: Required<TextureFormatCapabilities> = {\n      format,\n      create: info.f ?? true,\n      render: info.render ?? true,\n      filter: info.filter ?? true,\n      blend: info.blend ?? true,\n      store: info.store ?? true\n    };\n\n    const formatInfo = getTextureFormatInfo(format);\n    const isDepthStencil = format.startsWith('depth') || format.startsWith('stencil');\n    const isSigned = formatInfo?.signed;\n    const isInteger = formatInfo?.integer;\n    const isWebGLSpecific = formatInfo?.webgl;\n\n    // signed formats are not renderable\n    formatCapabilities.render &&= !isSigned;\n    // signed and integer formats are not filterable\n    formatCapabilities.filter &&= !isDepthStencil && !isSigned && !isInteger && !isWebGLSpecific;\n\n    return formatCapabilities;\n  }\n}\n\nexport const textureFormatDecoder = new TextureFormatDecoder();\n\n// HELPERS\n\n/**\n * Decodes a texture format, returning e.g. attatchment type, components, byte length and flags (integer, signed, normalized)\n */\nfunction getTextureFormatInfo(format: TextureFormat): TextureFormatInfo {\n  let formatInfo: TextureFormatInfo = getTextureFormatInfoUsingTable(format);\n\n  if (textureFormatDecoder.isCompressed(format)) {\n    formatInfo.channels = 'rgb';\n    formatInfo.components = 3;\n    formatInfo.bytesPerPixel = 1;\n    formatInfo.srgb = false;\n    formatInfo.compressed = true;\n\n    const blockSize = getCompressedTextureBlockSize(format);\n    if (blockSize) {\n      formatInfo.blockWidth = blockSize.blockWidth;\n      formatInfo.blockHeight = blockSize.blockHeight;\n    }\n  }\n\n  // Fill in missing information that can be derived from the format string\n  const matches = RGB_FORMAT_REGEX.exec(format as string);\n  if (matches) {\n    const [, channels, length, type, srgb, suffix] = matches;\n    const dataType = `${type}${length}` as NormalizedDataType;\n    const decodedType = getDataTypeInfo(dataType);\n    const bits = decodedType.byteLength * 8;\n    const components = channels.length as 1 | 2 | 3 | 4;\n    const bitsPerChannel: [number, number, number, number] = [\n      bits,\n      components >= 2 ? bits : 0,\n      components >= 3 ? bits : 0,\n      components >= 4 ? bits : 0\n    ];\n\n    formatInfo = {\n      format,\n      attachment: formatInfo.attachment,\n      dataType: decodedType.signedType,\n      components,\n      channels: channels as 'r' | 'rg' | 'rgb' | 'rgba',\n      integer: decodedType.integer,\n      signed: decodedType.signed,\n      normalized: decodedType.normalized,\n      bitsPerChannel,\n      bytesPerPixel: decodedType.byteLength * channels.length,\n      packed: formatInfo.packed,\n      srgb: formatInfo.srgb\n    };\n\n    if (suffix === '-webgl') {\n      formatInfo.webgl = true;\n    }\n    // dataType - overwritten by decodedType\n    if (srgb === '-srgb') {\n      formatInfo.srgb = true;\n    }\n  }\n\n  if (format.endsWith('-webgl')) {\n    formatInfo.webgl = true;\n  }\n  if (format.endsWith('-srgb')) {\n    formatInfo.srgb = true;\n  }\n\n  return formatInfo;\n}\n\n/** Decode texture format info from the table */\nfunction getTextureFormatInfoUsingTable(format: TextureFormat): TextureFormatInfo {\n  const info = getTextureFormatDefinition(format);\n\n  const bytesPerPixel = info.bytesPerPixel || 1;\n  const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];\n  delete info.bitsPerChannel;\n  delete info.bytesPerPixel;\n  delete info.f;\n  delete info.render;\n  delete info.filter;\n  delete info.blend;\n  delete info.store;\n\n  const formatInfo: TextureFormatInfo = {\n    ...info,\n    format,\n    attachment: info.attachment || 'color',\n    channels: info.channels || 'r',\n    components: (info.components || info.channels?.length || 1) as 1 | 2 | 3 | 4,\n    bytesPerPixel,\n    bitsPerChannel,\n    dataType: info.dataType || 'uint8',\n    srgb: info.srgb ?? false,\n    packed: info.packed ?? false,\n    webgl: info.webgl ?? false,\n    integer: info.integer ?? false,\n    signed: info.signed ?? false,\n    normalized: info.normalized ?? false,\n    compressed: info.compressed ?? false\n  };\n\n  return formatInfo;\n}\n\n/** Parses ASTC block widths from format string */\nfunction getCompressedTextureBlockSize(\n  format: TextureFormatCompressed\n): {blockWidth: number; blockHeight: number} | null {\n  const REGEX = /.*-(\\d+)x(\\d+)-.*/;\n  const matches = REGEX.exec(format as string);\n  if (matches) {\n    const [, blockWidth, blockHeight] = matches;\n    return {blockWidth: Number(blockWidth), blockHeight: Number(blockHeight)};\n  }\n  return null;\n}\n\n/*\n'r8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'r8snorm':\t{s: \"float\"}, // \t\t\u2713\t\t},\n'r8uint':\t{s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'r8sint':\t{s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'rg8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rg8snorm':\t{s: \"float\"}, // \t\t\u2713\t\t},\n'rg8uint':\t{s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'rg8sint':\t{s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'rgba8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t\u2713},\n'rgba8unorm-srgb': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rgba8snorm':\t{s: \"float\"}, // \t\t\u2713\t\t\u2713},\n'rgba8uint':\t{s: \"uint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'rgba8sint':\t{s: \"sint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'bgra8unorm':\t{s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'bgra8unorm-srgb': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n// 16-bit per component\t\t\t\t\t\n'r16uint': {s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'r16sint': {s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'r16float': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rg16uint': {s: \"uint\"}, // \t\u2713\t\u2713\t\t},\n'rg16sint': {s: \"sint\"}, // \t\u2713\t\u2713\t\t},\n'rg16float': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t},\n'rgba16uint': {s: \"uint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'rgba16sint': {s: \"sint\"}, // \t\u2713\t\u2713\t\t\u2713},\n'rgba16float': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t\u2713},\n// 32-bit per component\t\t\t\t\t\n'r32uint': {s: \"uint\"}, // \t\u2713\t\t\t\u2713},\n'r32sint': {s: \"sint\"}, // \t\u2713\t\t\t\u2713},\n'r32float': {\"unfilterable-float\"\t\u2713\t\u2713\t\t\u2713},\n'rg32uint': {s: \"uint\"}, // \t\u2713\t\t\t\u2713},\n'rg32sint': {s: \"sint\"}, // \t\u2713\t\t\t\u2713},\n'rg32float': {\"unfilterable-float\"\t\u2713\t\t\t\u2713},\n'rgba32uint': {s: \"uint\"}, // \t\u2713\t\t\t\u2713},\n'rgba32sint': {s: \"sint\"}, // \t\u2713\t\t\t\u2713},\n'rgba32float': {\"unfilterable-float\"\t\u2713\t\t\t\u2713},\n// mixed component width\t\t\t\t\t\n'rgb10a2unorm': {s: \"float\"}, // \t\u2713\t\u2713\t\u2713\t}\n'rg11b10ufloat': {s: \"float\"}, // \t\t\u2713\t\t}\n// Format\tBytes per texel\tAspect\tGPUTextureSampleType\tValid image copy source\tValid image copy destination\n'stencil8': {1 \u2212 4\tstencil\t\"uint\"\t\u2713}\n'depth16unorm': {2\tdepth\t\"depth\"\t\u2713}\n'depth24plus': {4\tdepth\t\"depth\"\t\u2717}\n'depth24plus': {stencil8\t4 \u2212 8\tdepth\t\"depth\"\t\u2717}\n'stencil': {s: \"uint\"}, // \t\u2713}\n'depth32float': {4\tdepth\t\"depth\"\t\u2713\t\u2717}\n'depth24unorm': {stencil8\t4\tdepth\t\"depth\"\t\u2717}\n'stencil': {s: \"uint\"}, // \t\u2713}\n'depth32float': {stencil8}\n\n// Format\tBytes per block\tGPUTextureSampleType\tBlock Size\tFeature\n'rgb9e5ufloat': {c: 4, s: \"float\",\tbpp: 4/(1*1)},\n\n'bc1-rgba-unorm': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc1-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-unorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-snorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-unorm': {c: 2. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-snorm': { },\n'bc6h-rgb-ufloat': {\t16 },\n'bc6h-rgb-float': { },\n'bc7-rgba-unorm': {\t16 },\n'bc7-rgba-unorm-srgb': { },\n\n'etc2-rgb8unorm': {\t8\t\"float\"\t4 \u00D7 4\ttexture-compression-etc2 },\n'etc2-rgb8unorm-srgb': { },\n'etc2-rgb8a1unorm': {\t8 },\n'etc2-rgb8a1unorm-srgb': { },\n'etc2-rgba8unorm': {\t16 },\n'etc2-rgba8unorm-srgb': { },\n\n'eac-r11unorm': {\t8 },\n'eac-r11snorm': { },\n'eac-rg11unorm': {\t16 },\n'eac-rg11snorm': { },\n\n'astc-4x4-unorm': {\t16\t\"float\"\t4 \u00D7 4\ttexture-compression-astc },\n'astc-4x4-unorm-srgb': { },\n'astc-5x4-unorm': {\t16\t5 \u00D7 4 },\n'astc-5x4-unorm-srgb': { },\n'astc-5x5-unorm': {\t16\t5 \u00D7 5 },\n'astc-5x5-unorm-srgb': { },\n'astc-6x5-unorm': {\t16\t6 \u00D7 5 },\n'astc-6x5-unorm-srgb': { },\n'astc-6x6-unorm': {\t16\t6 \u00D7 6 },\n'astc-6x6-unorm-srgb': { },\n'astc-8x5-unorm': {\t16\t8 \u00D7 5 },\n'astc-8x5-unorm-srgb': { },\n'astc-8x6-unorm': {\t16\t8 \u00D7 6 },\n'astc-8x6-unorm-srgb': { },\n'astc-8x8-unorm': {\t16\t8 \u00D7 8 },\n'astc-8x8-unorm-srgb': { },\n'astc-10x5-unorm': {\t16\t10 \u00D7 5 },\n'astc-10x5-unorm-srgb': { },\n'astc-10x6-unorm': {\t16\t10 \u00D7 6 },\n'astc-10x6-unorm-srgb': { },\n'astc-10x8-unorm': {\t16\t10 \u00D7 8 },\n'astc-10x8-unorm-srgb': { },\n'astc-10x10-unorm': {\t16\t10 \u00D7 10 },\n'astc-10x10-unorm-srgb': { },\n'astc-12x10-unorm': {\t16\t12 \u00D7 10 },\n'astc-12x10-unorm-srgb': { },\n'astc-12x12-unorm': {\t16 },\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Built-in data types that can be used to initialize textures\n * @note ImageData can be used for contiguous 8 bit data via Uint8ClampedArray\n */\nexport type ExternalImage =\n  | ImageBitmap\n  | ImageData\n  | HTMLImageElement\n  | HTMLVideoElement\n  | VideoFrame\n  | HTMLCanvasElement\n  | OffscreenCanvas;\n\nexport type ExternalImageData = {\n  data: ArrayBuffer | SharedArrayBuffer | ArrayBufferView;\n  byteOffset?: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n};\n\n/** Check if data is an external image */\nexport function isExternalImage(data: unknown): data is ExternalImage {\n  return (\n    (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n    (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n    (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) ||\n    (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) ||\n    (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) ||\n    (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n    (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n  );\n}\n\n/** Determine size (width and height) of provided image data */\nexport function getExternalImageSize(data: ExternalImage): {width: number; height: number} {\n  if (\n    (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n    (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n    (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n    (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n  ) {\n    return {width: data.width, height: data.height};\n  }\n  if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n    return {width: data.naturalWidth, height: data.naturalHeight};\n  }\n  if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n    return {width: data.videoWidth, height: data.videoHeight};\n  }\n  if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n    // TODO: is this the right choice for width and height?\n    return {width: data.displayWidth, height: data.displayHeight};\n  }\n  throw new Error('Unknown image type');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/uid';\nimport type {VertexFormat, VertexFormatInfo} from '../shadertypes/vertex-arrays/vertex-formats';\nimport type {TextureFormat, TextureFormatInfo} from '../shadertypes/textures/texture-formats';\nimport type {CanvasContext, CanvasContextProps} from './canvas-context';\nimport type {BufferProps} from './resources/buffer';\nimport {Buffer} from './resources/buffer';\nimport type {RenderPipeline, RenderPipelineProps} from './resources/render-pipeline';\nimport type {ComputePipeline, ComputePipelineProps} from './resources/compute-pipeline';\nimport type {Sampler, SamplerProps} from './resources/sampler';\nimport type {Shader, ShaderProps} from './resources/shader';\nimport type {Texture, TextureProps} from './resources/texture';\nimport type {ExternalTexture, ExternalTextureProps} from './resources/external-texture';\nimport type {Framebuffer, FramebufferProps} from './resources/framebuffer';\nimport type {RenderPass, RenderPassProps} from './resources/render-pass';\nimport type {ComputePass, ComputePassProps} from './resources/compute-pass';\nimport type {CommandEncoder, CommandEncoderProps} from './resources/command-encoder';\nimport type {CommandBuffer} from './resources/command-buffer';\nimport type {VertexArray, VertexArrayProps} from './resources/vertex-array';\nimport type {TransformFeedback, TransformFeedbackProps} from './resources/transform-feedback';\nimport type {QuerySet, QuerySetProps} from './resources/query-set';\n\nimport {getVertexFormatInfo} from '../shadertypes/vertex-arrays/decode-vertex-format';\nimport {textureFormatDecoder} from '../shadertypes/textures/texture-format-decoder';\nimport type {ExternalImage} from '../image-utils/image-types';\nimport {isExternalImage, getExternalImageSize} from '../image-utils/image-types';\n\n/**\n * Identifies the GPU vendor and driver.\n * @note Chrome WebGPU does not provide much information, though more can be enabled with\n * @see https://developer.chrome.com/blog/new-in-webgpu-120#adapter_information_updates\n * chrome://flags/#enable-webgpu-developer-features\n */\nexport type DeviceInfo = {\n  /** Type of device */\n  type: 'webgl' | 'webgpu' | 'null' | 'unknown';\n  /** Vendor (name of GPU vendor, Apple, nVidia etc */\n  vendor: string;\n  /** Renderer (usually driver name) */\n  renderer: string;\n  /** version of driver */\n  version: string;\n  /** family of GPU */\n  gpu: 'nvidia' | 'amd' | 'intel' | 'apple' | 'software' | 'unknown';\n  /** Type of GPU () */\n  gpuType: 'discrete' | 'integrated' | 'cpu' | 'unknown';\n  /** GPU architecture */\n  gpuArchitecture?: string; // 'common-3' on Apple\n  /** GPU driver backend. Can sometimes be sniffed */\n  gpuBackend?: 'opengl' | 'opengles' | 'metal' | 'd3d11' | 'd3d12' | 'vulkan' | 'unknown';\n  /** If this is a fallback adapter */\n  fallback?: boolean;\n  /** Shader language supported by device.createShader() */\n  shadingLanguage: 'wgsl' | 'glsl';\n  /** Highest supported shader language version: GLSL 3.00 = 300, WGSL 1.00 = 100 */\n  shadingLanguageVersion: number;\n};\n\n/** Limits for a device (max supported sizes of resources, max number of bindings etc) */\nexport abstract class DeviceLimits {\n  /** max number of TextureDimension1D */\n  abstract maxTextureDimension1D: number;\n  /** max number of TextureDimension2D */\n  abstract maxTextureDimension2D: number;\n  /** max number of TextureDimension3D */\n  abstract maxTextureDimension3D: number;\n  /** max number of TextureArrayLayers */\n  abstract maxTextureArrayLayers: number;\n  /** max number of BindGroups */\n  abstract maxBindGroups: number;\n  /** max number of DynamicUniformBuffers per PipelineLayout */\n  abstract maxDynamicUniformBuffersPerPipelineLayout: number;\n  /** max number of DynamicStorageBuffers per PipelineLayout */\n  abstract maxDynamicStorageBuffersPerPipelineLayout: number;\n  /** max number of SampledTextures per ShaderStage */\n  abstract maxSampledTexturesPerShaderStage: number;\n  /** max number of Samplers per ShaderStage */\n  abstract maxSamplersPerShaderStage: number;\n  /** max number of StorageBuffers per ShaderStage */\n  abstract maxStorageBuffersPerShaderStage: number;\n  /** max number of StorageTextures per ShaderStage */\n  abstract maxStorageTexturesPerShaderStage: number;\n  /** max number of UniformBuffers per ShaderStage */\n  abstract maxUniformBuffersPerShaderStage: number;\n  /** max number of UniformBufferBindingSize */\n  abstract maxUniformBufferBindingSize: number;\n  /** max number of StorageBufferBindingSize */\n  abstract maxStorageBufferBindingSize: number;\n  /** min UniformBufferOffsetAlignment */\n  abstract minUniformBufferOffsetAlignment: number;\n  /** min StorageBufferOffsetAlignment */\n  abstract minStorageBufferOffsetAlignment: number;\n  /** max number of VertexBuffers */\n  abstract maxVertexBuffers: number;\n  /** max number of VertexAttributes */\n  abstract maxVertexAttributes: number;\n  /** max number of VertexBufferArrayStride */\n  abstract maxVertexBufferArrayStride: number;\n  /** max number of InterStageShaderComponents */\n  abstract maxInterStageShaderVariables: number;\n  /** max number of ComputeWorkgroupStorageSize */\n  abstract maxComputeWorkgroupStorageSize: number;\n  /** max number of ComputeInvocations per Workgroup */\n  abstract maxComputeInvocationsPerWorkgroup: number;\n  /** max ComputeWorkgroupSizeX */\n  abstract maxComputeWorkgroupSizeX: number;\n  /** max ComputeWorkgroupSizeY */\n  abstract maxComputeWorkgroupSizeY: number;\n  /** max ComputeWorkgroupSizeZ */\n  abstract maxComputeWorkgroupSizeZ: number;\n  /** max ComputeWorkgroupsPerDimension */\n  abstract maxComputeWorkgroupsPerDimension: number;\n}\n\n/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */\nexport class DeviceFeatures {\n  protected features: Set<DeviceFeature>;\n  protected disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n\n  constructor(\n    features: DeviceFeature[] = [],\n    disabledFeatures: Partial<Record<DeviceFeature, boolean>>\n  ) {\n    this.features = new Set<DeviceFeature>(features);\n    this.disabledFeatures = disabledFeatures || {};\n  }\n\n  *[Symbol.iterator](): IterableIterator<DeviceFeature> {\n    yield* this.features;\n  }\n\n  has(feature: DeviceFeature): boolean {\n    return !this.disabledFeatures?.[feature] && this.features.has(feature);\n  }\n}\n\n/** Device feature names */\nexport type DeviceFeature =\n  | WebGPUDeviceFeature\n  | WebGLDeviceFeature\n  | WebGLCompressedTextureFeatures;\n// | ChromeExperimentalFeatures\n\n/** Chrome-specific extensions. Expected to eventually become standard features. */\n// export type ChromeExperimentalFeatures = ;\n\nexport type WebGPUDeviceFeature =\n  | 'depth-clip-control'\n  | 'depth32float-stencil8'\n  | 'texture-compression-bc'\n  | 'texture-compression-bc-sliced-3d'\n  | 'texture-compression-etc2'\n  | 'texture-compression-astc'\n  | 'texture-compression-astc-sliced-3d'\n  | 'timestamp-query'\n  | 'indirect-first-instance'\n  | 'shader-f16'\n  | 'rg11b10ufloat-renderable' // Is the rg11b10ufloat texture format renderable?\n  | 'bgra8unorm-storage' // Can the bgra8unorm texture format be used in storage buffers?\n  | 'float32-filterable' // Is the float32 format filterable?\n  | 'float32-blendable' // Is the float32 format blendable?\n  | 'clip-distances'\n  | 'dual-source-blending'\n  | 'subgroups';\n// | 'depth-clamping' // removed from the WebGPU spec...\n// | 'pipeline-statistics-query' // removed from the WebGPU spec...\n\nexport type WebGLDeviceFeature =\n  // webgl extension features\n  | 'timer-query-webgl' // unify with WebGPU timestamp-query?\n  | 'compilation-status-async-webgl' // Non-blocking shader compile/link status query available\n  | 'provoking-vertex-webgl' // parameters.provokingVertex\n  | 'polygon-mode-webgl' // parameters.polygonMode and parameters.polygonOffsetLine\n\n  // GLSL extension features\n  | 'shader-noperspective-interpolation-webgl' // Vertex outputs & fragment inputs can have a `noperspective` interpolation qualifier.\n  | 'shader-conservative-depth-webgl' // GLSL `gl_FragDepth` qualifiers `depth_unchanged` etc can enable early depth test\n  | 'shader-clip-cull-distance-webgl' // Makes gl_ClipDistance and gl_CullDistance available in shaders\n\n  // texture rendering\n  | 'float32-renderable-webgl'\n  | 'float16-renderable-webgl'\n  | 'rgb9e5ufloat-renderable-webgl'\n  | 'snorm8-renderable-webgl'\n  | 'norm16-renderable-webgl'\n  | 'snorm16-renderable-webgl'\n\n  // texture filtering\n  | 'float16-filterable-webgl'\n  | 'texture-filterable-anisotropic-webgl'\n\n  // texture storage bindings\n  | 'bgra8unorm-storage'\n\n  // texture blending\n  | 'texture-blend-float-webgl';\n\ntype WebGLCompressedTextureFeatures =\n  | 'texture-compression-bc5-webgl'\n  | 'texture-compression-bc7-webgl'\n  | 'texture-compression-etc1-webgl'\n  | 'texture-compression-pvrtc-webgl'\n  | 'texture-compression-atc-webgl';\n\n/** Texture format capabilities that have been checked against a specific device */\nexport type DeviceTextureFormatCapabilities = {\n  format: TextureFormat;\n  /** Can the format be created and sampled?*/\n  create: boolean;\n  /** Is the format renderable. */\n  render: boolean;\n  /** Is the format filterable. */\n  filter: boolean;\n  /** Is the format blendable. */\n  blend: boolean;\n  /** Is the format storeable. */\n  store: boolean;\n};\n\n/** Device properties */\nexport type DeviceProps = {\n  /** string id for debugging. Stored on the object, used in logging and set on underlying GPU objects when feasible. */\n  id?: string;\n  /** Properties for creating a default canvas context */\n  createCanvasContext?: CanvasContextProps | true;\n  /** Control which type of GPU is preferred on systems with both integrated and discrete GPU. Defaults to \"high-performance\" / discrete GPU. */\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  /** Hints that device creation should fail if no hardware GPU is available (if the system performance is \"low\"). */\n  failIfMajorPerformanceCaveat?: boolean;\n\n  /** WebGL specific: Properties passed through to WebGL2RenderingContext creation: `canvas.getContext('webgl2', props.webgl)` */\n  webgl?: WebGLContextProps;\n\n  // CALLBACKS\n\n  /** Error handler. If it returns a probe logger style function, it will be called at the site of the error to optimize console error links. */\n  onError?: (error: Error, context?: unknown) => unknown;\n  /** Called when the size of a CanvasContext's canvas changes */\n  onResize?: (ctx: CanvasContext, info: {oldPixelSize: [number, number]}) => unknown;\n  /** Called when the absolute position of a CanvasContext's canvas changes. Must set `CanvasContextProps.trackPosition: true` */\n  onPositionChange?: (ctx: CanvasContext, info: {oldPosition: [number, number]}) => unknown;\n  /** Called when the visibility of a CanvasContext's canvas changes */\n  onVisibilityChange?: (ctx: CanvasContext) => unknown;\n  /** Called when the device pixel ratio of a CanvasContext's canvas changes */\n  onDevicePixelRatioChange?: (ctx: CanvasContext, info: {oldRatio: number}) => unknown;\n\n  // DEBUG SETTINGS\n\n  /** Turn on implementation defined checks that slow down execution but help break where errors occur */\n  debug?: boolean;\n  /** Show shader source in browser? The default is `'error'`, meaning that logs are shown when shader compilation has errors */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n  /** Renders a small version of updated Framebuffers into the primary canvas context. Can be set in console luma.log.set('debug-framebuffers', true) */\n  debugFramebuffers?: boolean;\n  /** Traces resource caching, reuse, and destroys in the PipelineFactory */\n  debugFactories?: boolean;\n  /** WebGL specific - Trace WebGL calls (instruments WebGL2RenderingContext at the expense of performance). Can be set in console luma.log.set('debug-webgl', true)  */\n  debugWebGL?: boolean;\n  /** WebGL specific - Initialize the SpectorJS WebGL debugger. Can be set in console luma.log.set('debug-spectorjs', true)  */\n  debugSpectorJS?: boolean;\n  /** WebGL specific - SpectorJS URL. Override if CDN is down or different SpectorJS version is desired. */\n  debugSpectorJSUrl?: string;\n\n  // EXPERIMENTAL SETTINGS - subject to change\n\n  /** adapter.create() returns the existing Device if the provided canvas' WebGL context is already associated with a Device.  */\n  _reuseDevices?: boolean;\n  /** WebGPU specific - Request a Device with the highest limits supported by platform. On WebGPU devices can be created with minimal limits. */\n  _requestMaxLimits?: boolean;\n  /** Disable specific features */\n  _disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n  /** WebGL specific - Initialize all features on startup */\n  _initializeFeatures?: boolean;\n  /** Enable shader caching (via ShaderFactory) */\n  _cacheShaders?: boolean;\n  /** Enable shader caching (via PipelineFactory) */\n  _cachePipelines?: boolean;\n  /** Never destroy cached shaders and pipelines */\n  _cacheDestroyPolicy?: 'unused' | 'never';\n\n  /** @deprecated Internal, Do not use directly! Use `luma.attachDevice()` to attach to pre-created contexts/devices. */\n  _handle?: unknown; // WebGL2RenderingContext | GPUDevice | null;\n};\n\n/** WebGL independent copy of WebGLContextAttributes */\ntype WebGLContextProps = {\n  /** indicates if the canvas contains an alpha buffer. */\n  alpha?: boolean;\n  /** hints the user agent to reduce the latency by desynchronizing the canvas paint cycle from the event loop */\n  desynchronized?: boolean;\n  /** indicates whether or not to perform anti-aliasing. */\n  antialias?: boolean;\n  /** indicates that the render target has a stencil buffer of at least `8` bits. */\n  stencil?: boolean;\n  /** indicates that the drawing buffer has a depth buffer of at least 16 bits. */\n  depth?: boolean;\n  /** indicates if a context will be created if the system performance is low or if no hardware GPU is available. */\n  failIfMajorPerformanceCaveat?: boolean;\n  /** Selects GPU */\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  /** page compositor will assume the drawing buffer contains colors with pre-multiplied alpha. */\n  premultipliedAlpha?: boolean;\n  /** buffers will not be cleared and will preserve their values until cleared or overwritten by the author. */\n  preserveDrawingBuffer?: boolean;\n};\n\n/**\n * Create and attach devices for a specific backend. Currently static methods on each device\n */\nexport interface DeviceFactory {\n  // new (props: DeviceProps): Device; Constructor isn't used\n  type: string;\n  isSupported(): boolean;\n  create(props: DeviceProps): Promise<Device>;\n  attach?(handle: unknown): Device;\n}\n\n/**\n * WebGPU Device/WebGL context abstraction\n */\nexport abstract class Device {\n  static defaultProps: Required<DeviceProps> = {\n    id: null!,\n    powerPreference: 'high-performance',\n    failIfMajorPerformanceCaveat: false,\n    createCanvasContext: undefined!,\n    // WebGL specific\n    webgl: {},\n\n    // Callbacks\n    // eslint-disable-next-line handle-callback-err\n    onError: (error: Error, context: unknown) => {},\n    onResize: (context: CanvasContext, info: {oldPixelSize: [number, number]}) => {\n      const [width, height] = context.getDevicePixelSize();\n      log.log(1, `${context} resized => ${width}x${height}px`)();\n    },\n    onPositionChange: (context: CanvasContext, info: {oldPosition: [number, number]}) => {\n      const [left, top] = context.getPosition();\n      log.log(1, `${context} repositioned => ${left},${top}`)();\n    },\n    onVisibilityChange: (context: CanvasContext) =>\n      log.log(1, `${context} Visibility changed ${context.isVisible}`)(),\n    onDevicePixelRatioChange: (context: CanvasContext, info: {oldRatio: number}) =>\n      log.log(1, `${context} DPR changed ${info.oldRatio} => ${context.devicePixelRatio}`)(),\n\n    // Debug flags\n    debug: log.get('debug') || undefined!,\n    debugShaders: log.get('debug-shaders') || undefined!,\n    debugFramebuffers: Boolean(log.get('debug-framebuffers')),\n    debugFactories: Boolean(log.get('debug-factories')),\n    debugWebGL: Boolean(log.get('debug-webgl')),\n    debugSpectorJS: undefined!, // Note: log setting is queried by the spector.js code\n    debugSpectorJSUrl: undefined!,\n\n    // Experimental\n    _reuseDevices: false,\n    _requestMaxLimits: true,\n    _cacheShaders: false,\n    _cachePipelines: false,\n    _cacheDestroyPolicy: 'unused',\n    // TODO - Change these after confirming things work as expected\n    _initializeFeatures: true,\n    _disabledFeatures: {\n      'compilation-status-async-webgl': true\n    },\n\n    // INTERNAL\n    _handle: undefined!\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'Device';\n  }\n\n  toString(): string {\n    return `Device(${this.id})`;\n  }\n\n  /** id of this device, primarily for debugging */\n  readonly id: string;\n  /** type of this device */\n  abstract readonly type: 'webgl' | 'webgpu' | 'null' | 'unknown';\n  abstract readonly handle: unknown;\n  abstract commandEncoder: CommandEncoder;\n\n  /** A copy of the device props  */\n  readonly props: Required<DeviceProps>;\n  /** Available for the application to store data on the device */\n  userData: {[key: string]: unknown} = {};\n  /** stats */\n  readonly statsManager: StatsManager = lumaStats;\n  /** An abstract timestamp used for change tracking */\n  timestamp: number = 0;\n\n  /** True if this device has been reused during device creation (app has multiple references) */\n  _reused: boolean = false;\n  /** Used by other luma.gl modules to store data on the device */\n  _lumaData: {[key: string]: unknown} = {};\n\n  // Capabilities\n\n  /** Information about the device (vendor, versions etc) */\n  abstract info: DeviceInfo;\n  /** Optional capability discovery */\n  abstract features: DeviceFeatures;\n  /** WebGPU style device limits */\n  abstract get limits(): DeviceLimits;\n\n  // Texture helpers\n\n  /** Optimal TextureFormat for displaying 8-bit depth, standard dynamic range content on this system. */\n  abstract preferredColorFormat: 'rgba8unorm' | 'bgra8unorm';\n  /** Default depth format used on this system */\n  abstract preferredDepthFormat: 'depth16' | 'depth24plus' | 'depth32float';\n\n  protected _textureCaps: Partial<Record<TextureFormat, DeviceTextureFormatCapabilities>> = {};\n\n  constructor(props: DeviceProps) {\n    this.props = {...Device.defaultProps, ...props};\n    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());\n  }\n\n  abstract destroy(): void;\n\n  getVertexFormatInfo(format: VertexFormat): VertexFormatInfo {\n    return getVertexFormatInfo(format);\n  }\n\n  isVertexFormatSupported(format: VertexFormat): boolean {\n    return true;\n  }\n\n  /** Returns information about a texture format, such as data type, channels, bits per channel, compression etc */\n  getTextureFormatInfo(format: TextureFormat): TextureFormatInfo {\n    return textureFormatDecoder.getInfo(format);\n  }\n\n  /** Determines what operations are supported on a texture format on this particular device (checks against supported device features) */\n  getTextureFormatCapabilities(format: TextureFormat): DeviceTextureFormatCapabilities {\n    let textureCaps = this._textureCaps[format];\n    if (!textureCaps) {\n      const capabilities = this._getDeviceTextureFormatCapabilities(format);\n      textureCaps = this._getDeviceSpecificTextureFormatCapabilities(capabilities);\n      this._textureCaps[format] = textureCaps;\n    }\n    return textureCaps;\n  }\n\n  /** Return the implementation specific alignment for a texture format. 1 on WebGL, 256 on WebGPU */\n  abstract getTextureByteAlignment(): number;\n\n  /** Calculates the number of mip levels for a texture of width, height and in case of 3d textures only, depth */\n  getMipLevelCount(width: number, height: number, depth3d: number = 1): number {\n    const maxSize = Math.max(width, height, depth3d);\n    return 1 + Math.floor(Math.log2(maxSize));\n  }\n\n  /** Check if data is an external image */\n  isExternalImage(data: unknown): data is ExternalImage {\n    return isExternalImage(data);\n  }\n\n  /** Get the size of an external image */\n  getExternalImageSize(data: ExternalImage): {width: number; height: number} {\n    return getExternalImageSize(data);\n  }\n\n  /** Check if device supports a specific texture format (creation and `nearest` sampling) */\n  isTextureFormatSupported(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).create;\n  }\n\n  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */\n  isTextureFormatFilterable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).filter;\n  }\n\n  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */\n  isTextureFormatRenderable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).render;\n  }\n\n  /** Check if a specific texture format is GPU compressed */\n  isTextureFormatCompressed(format: TextureFormat): boolean {\n    return textureFormatDecoder.isCompressed(format);\n  }\n\n  // DEBUG METHODS\n\n  pushDebugGroup(groupLabel: string): void {\n    this.commandEncoder.pushDebugGroup(groupLabel);\n  }\n\n  popDebugGroup(): void {\n    this.commandEncoder?.popDebugGroup();\n  }\n\n  insertDebugMarker(markerLabel: string): void {\n    this.commandEncoder?.insertDebugMarker(markerLabel);\n  }\n\n  // Device loss\n\n  /** `true` if device is already lost */\n  abstract get isLost(): boolean;\n\n  /** Promise that resolves when device is lost */\n  abstract readonly lost: Promise<{reason: 'destroyed'; message: string}>;\n\n  /**\n   * Trigger device loss.\n   * @returns `true` if context loss could actually be triggered.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice(): boolean {\n    return false;\n  }\n\n  /** A monotonic counter for tracking buffer and texture updates */\n  incrementTimestamp(): number {\n    return this.timestamp++;\n  }\n\n  /**\n   * Reports Device errors in a way that optimizes for developer experience / debugging.\n   * - Logs so that the console error links directly to the source code that generated the error.\n   * - Includes the object that reported the error in the log message, even if the error is asynchronous.\n   *\n   * Conventions when calling reportError():\n   * - Always call the returned function - to ensure error is logged, at the error site\n   * - Follow with a call to device.debug() - to ensure that the debugger breaks at the error site\n   *\n   * @param error - the error to report. If needed, just create a new Error object with the appropriate message.\n   * @param context - pass `this` as context, otherwise it may not be available in the debugger for async errors.\n   * @returns the logger function returned by device.props.onError() so that it can be called from the error site.\n   *\n   * @example\n   *   device.reportError(new Error(...), this)();\n   *   device.debug();\n   */\n  reportError(error: Error, context: unknown, ...args: unknown[]): () => unknown {\n    // Call the error handler\n    const isHandled = this.props.onError(error, context);\n    if (!isHandled) {\n      // Note: Returns a function that must be called: `device.reportError(...)()`\n      return log.error(error.message, context, ...args);\n    }\n    return () => {};\n  }\n\n  /** Break in the debugger - if device.props.debug is true */\n  debug(): void {\n    if (this.props.debug) {\n      // @ts-ignore\n      debugger; // eslint-disable-line\n    } else {\n      // TODO(ibgreen): Does not appear to be printed in the console\n      const message = `\\\n'Type luma.log.set({debug: true}) in console to enable debug breakpoints',\nor create a device with the 'debug: true' prop.`;\n      log.once(0, message)();\n    }\n  }\n\n  // Canvas context\n\n  /** Default / primary canvas context. Can be null as WebGPU devices can be created without a CanvasContext */\n  abstract canvasContext: CanvasContext | null;\n\n  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */\n  getDefaultCanvasContext(): CanvasContext {\n    if (!this.canvasContext) {\n      throw new Error('Device has no default CanvasContext. See props.createCanvasContext');\n    }\n    return this.canvasContext;\n  }\n\n  /** Creates a new CanvasContext (WebGPU only) */\n  abstract createCanvasContext(props?: CanvasContextProps): CanvasContext;\n\n  /** Call after rendering a frame (necessary e.g. on WebGL OffscreenCanvas) */\n  abstract submit(commandBuffer?: CommandBuffer): void;\n\n  // Resource creation\n\n  /** Create a buffer */\n  abstract createBuffer(props: BufferProps | ArrayBuffer | ArrayBufferView): Buffer;\n\n  /** Create a texture */\n  abstract createTexture(props: TextureProps): Texture;\n\n  /** Create a temporary texture view of a video source */\n  abstract createExternalTexture(props: ExternalTextureProps): ExternalTexture;\n\n  /** Create a sampler */\n  abstract createSampler(props: SamplerProps): Sampler;\n\n  /** Create a Framebuffer. Must have at least one attachment. */\n  abstract createFramebuffer(props: FramebufferProps): Framebuffer;\n\n  /** Create a shader */\n  abstract createShader(props: ShaderProps): Shader;\n\n  /** Create a render pipeline (aka program) */\n  abstract createRenderPipeline(props: RenderPipelineProps): RenderPipeline;\n\n  /** Create a compute pipeline (aka program). WebGPU only. */\n  abstract createComputePipeline(props: ComputePipelineProps): ComputePipeline;\n\n  /** Create a vertex array */\n  abstract createVertexArray(props: VertexArrayProps): VertexArray;\n\n  abstract createCommandEncoder(props?: CommandEncoderProps): CommandEncoder;\n\n  /** Create a transform feedback (immutable set of output buffer bindings). WebGL only. */\n  abstract createTransformFeedback(props: TransformFeedbackProps): TransformFeedback;\n\n  abstract createQuerySet(props: QuerySetProps): QuerySet;\n\n  /** Create a RenderPass using the default CommandEncoder */\n  beginRenderPass(props?: RenderPassProps): RenderPass {\n    return this.commandEncoder.beginRenderPass(props);\n  }\n\n  /** Create a ComputePass using the default CommandEncoder*/\n  beginComputePass(props?: ComputePassProps): ComputePass {\n    return this.commandEncoder.beginComputePass(props);\n  }\n\n  /**\n   * Determines what operations are supported on a texture format, checking against supported device features\n   * Subclasses override to apply additional checks\n   */\n  protected abstract _getDeviceSpecificTextureFormatCapabilities(\n    format: DeviceTextureFormatCapabilities\n  ): DeviceTextureFormatCapabilities;\n\n  // DEPRECATED METHODS\n\n  /** @deprecated Use getDefaultCanvasContext() */\n  getCanvasContext(): CanvasContext {\n    return this.getDefaultCanvasContext();\n  }\n\n  // WebGL specific HACKS - enables app to remove webgl import\n  // Use until we have a better way to handle these\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToArrayWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      sourceAttachment?: number;\n      target?: Uint8Array | Uint16Array | Float32Array;\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Uint8Array | Uint16Array | Float32Array {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToBufferWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      target?: Buffer; // A new Buffer object is created when not provided.\n      targetByteOffset?: number; // byte offset in buffer object\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Buffer {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  setParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  getParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  withParametersWebGL(parameters: any, func: any): any {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use clear arguments in RenderPass */\n  clearWebGL(options?: {framebuffer?: Framebuffer; color?: any; depth?: any; stencil?: any}): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use for debugging only */\n  resetWebGL(): void {\n    throw new Error('not implemented');\n  }\n\n  // IMPLEMENTATION\n\n  /** Helper to get the canvas context props */\n  static _getCanvasContextProps(props: DeviceProps): CanvasContextProps | undefined {\n    return props.createCanvasContext === true ? {} : props.createCanvasContext;\n  }\n\n  protected _getDeviceTextureFormatCapabilities(\n    format: TextureFormat\n  ): DeviceTextureFormatCapabilities {\n    const genericCapabilities = textureFormatDecoder.getCapabilities(format);\n\n    // Check standard features\n    const checkFeature = (feature: DeviceFeature | boolean | undefined) =>\n      (typeof feature === 'string' ? this.features.has(feature) : feature) ?? true;\n\n    const supported = checkFeature(genericCapabilities.create);\n    return {\n      format,\n      create: supported,\n      render: supported && checkFeature(genericCapabilities.render),\n      filter: supported && checkFeature(genericCapabilities.filter),\n      blend: supported && checkFeature(genericCapabilities.blend),\n      store: supported && checkFeature(genericCapabilities.store)\n    } as const satisfies DeviceTextureFormatCapabilities;\n  }\n\n  /** Subclasses use this to support .createBuffer() overloads */\n  protected _normalizeBufferProps(props: BufferProps | ArrayBuffer | ArrayBufferView): BufferProps {\n    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // TODO(ibgreen) - fragile, as this is done before we merge with default options\n    // inside the Buffer constructor\n\n    const newProps = {...props};\n    // Deduce indexType\n    const usage = props.usage || 0;\n    if (usage & Buffer.INDEX) {\n      if (!props.indexType) {\n        if (props.data instanceof Uint32Array) {\n          newProps.indexType = 'uint32';\n        } else if (props.data instanceof Uint16Array) {\n          newProps.indexType = 'uint16';\n        }\n      }\n      if (!newProps.indexType) {\n        throw new Error('indices buffer content must be of type uint16 or uint32');\n      }\n    }\n\n    return newProps;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Log} from '@probe.gl/log';\nimport type {DeviceProps} from './device';\nimport {Device} from './device';\nimport {Adapter} from './adapter';\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var luma: Luma;\n}\n\nconst STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';\n\nconst ERROR_MESSAGE =\n  'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';\n\n/** Properties for creating a new device */\nexport type CreateDeviceProps = {\n  /** Selects the type of device. `best-available` uses webgpu if available, then webgl. */\n  type?: 'webgl' | 'webgpu' | 'null' | 'unknown' | 'best-available';\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n  /**\n   * Whether to wait for page to be loaded so that CanvasContext's can access the DOM.\n   * The browser only supports one 'load' event listener so it may be necessary for the application to set this to false to avoid conflicts.\n   */\n  waitForPageLoad?: boolean;\n} & DeviceProps;\n\n/** Properties for attaching an existing WebGL context or WebGPU device to a new luma Device */\nexport type AttachDeviceProps = {\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n} & DeviceProps;\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport class Luma {\n  static defaultProps: Required<CreateDeviceProps> = {\n    ...Device.defaultProps,\n    type: 'best-available',\n    adapters: undefined!,\n    waitForPageLoad: true\n  };\n\n  /** Global stats for all devices */\n  readonly stats: StatsManager = lumaStats;\n\n  /**\n   * Global log\n   *\n   * Assign luma.log.level in console to control logging: \\\n   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\n   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;\n   */\n  readonly log: Log = log;\n\n  /** Version of luma.gl */\n  readonly VERSION: string =\n    // Version detection using build plugin\n    // @ts-expect-error no-undef\n    typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'running from source';\n\n  spector: unknown;\n\n  protected preregisteredAdapters = new Map<string, Adapter>();\n\n  constructor() {\n    if (globalThis.luma) {\n      if (globalThis.luma.VERSION !== this.VERSION) {\n        log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();\n        log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();\n        throw new Error(`luma.gl - multiple versions detected: see console log`);\n      }\n\n      log.error('This version of luma.gl has already been initialized')();\n    }\n\n    log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();\n\n    globalThis.luma = this;\n  }\n\n  /** Creates a device. Asynchronously. */\n  async createDevice(props_: CreateDeviceProps = {}): Promise<Device> {\n    const props: Required<CreateDeviceProps> = {...Luma.defaultProps, ...props_};\n\n    const adapter = this.selectAdapter(props.type, props.adapters);\n    if (!adapter) {\n      throw new Error(ERROR_MESSAGE);\n    }\n\n    // Wait for page to load so that CanvasContext's can access the DOM.\n    if (props.waitForPageLoad) {\n      await adapter.pageLoaded;\n    }\n\n    return await adapter.create(props);\n  }\n\n  /**\n   * Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice).\n   * @param handle Externally created WebGL context or WebGPU device\n   */\n  async attachDevice(handle: unknown, props: AttachDeviceProps): Promise<Device> {\n    const type = this._getTypeFromHandle(handle, props.adapters);\n\n    const adapter = type && this.selectAdapter(type, props.adapters);\n    if (!adapter) {\n      throw new Error(ERROR_MESSAGE);\n    }\n\n    return await adapter?.attach?.(handle, props);\n  }\n\n  /**\n   * Global adapter registration.\n   * @deprecated Use props.adapters instead\n   */\n  registerAdapters(adapters: Adapter[]): void {\n    for (const deviceClass of adapters) {\n      this.preregisteredAdapters.set(deviceClass.type, deviceClass);\n    }\n  }\n\n  /** Get type strings for supported Devices */\n  getSupportedAdapters(adapters: Adapter[] = []): string[] {\n    const adapterMap = this._getAdapterMap(adapters);\n    return Array.from(adapterMap)\n      .map(([, adapter]) => adapter)\n      .filter(adapter => adapter.isSupported?.())\n      .map(adapter => adapter.type);\n  }\n\n  /** Get type strings for best available Device */\n  getBestAvailableAdapterType(adapters: Adapter[] = []): 'webgpu' | 'webgl' | 'null' | null {\n    const KNOWN_ADAPTERS: ('webgpu' | 'webgl' | 'null')[] = ['webgpu', 'webgl', 'null'];\n    const adapterMap = this._getAdapterMap(adapters);\n    for (const type of KNOWN_ADAPTERS) {\n      if (adapterMap.get(type)?.isSupported?.()) {\n        return type;\n      }\n    }\n    return null;\n  }\n\n  /** Select adapter of type from registered adapters */\n  selectAdapter(type: string, adapters: Adapter[] = []): Adapter | null {\n    let selectedType: string | null = type;\n    if (type === 'best-available') {\n      selectedType = this.getBestAvailableAdapterType(adapters);\n    }\n\n    const adapterMap = this._getAdapterMap(adapters);\n    return (selectedType && adapterMap.get(selectedType)) || null;\n  }\n\n  /**\n   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.\n   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.\n   */\n  enforceWebGL2(enforce: boolean = true, adapters: Adapter[] = []): void {\n    const adapterMap = this._getAdapterMap(adapters);\n    const webgl2Adapter = adapterMap.get('webgl');\n    if (!webgl2Adapter) {\n      log.warn('enforceWebGL2: webgl adapter not found')();\n    }\n    (webgl2Adapter as any)?.enforceWebGL2?.(enforce);\n  }\n\n  // DEPRECATED\n\n  /** @deprecated */\n  setDefaultDeviceProps(props: CreateDeviceProps): void {\n    Object.assign(Luma.defaultProps, props);\n  }\n\n  // HELPERS\n\n  /** Convert a list of adapters to a map */\n  protected _getAdapterMap(adapters: Adapter[] = []): Map<string, Adapter> {\n    const map = new Map(this.preregisteredAdapters);\n    for (const adapter of adapters) {\n      map.set(adapter.type, adapter);\n    }\n    return map;\n  }\n\n  /** Get type of a handle (for attachDevice) */\n  protected _getTypeFromHandle(\n    handle: unknown,\n    adapters: Adapter[] = []\n  ): 'webgpu' | 'webgl' | 'null' | null {\n    // TODO - delegate handle identification to adapters\n\n    // WebGL\n    if (handle instanceof WebGL2RenderingContext) {\n      return 'webgl';\n    }\n\n    if (typeof GPUDevice !== 'undefined' && handle instanceof GPUDevice) {\n      return 'webgpu';\n    }\n\n    // TODO - WebGPU does not yet seem to have a stable in-browser API, so we \"sniff\" for members instead\n    if ((handle as any)?.queue) {\n      return 'webgpu';\n    }\n\n    // null\n    if (handle === null) {\n      return 'null';\n    }\n\n    if (handle instanceof WebGLRenderingContext) {\n      log.warn('WebGL1 is not supported', handle)();\n    } else {\n      log.warn('Unknown handle type', handle)();\n    }\n\n    return null;\n  }\n}\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport const luma = new Luma();\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isBrowser} from '@probe.gl/env';\nimport {Device, DeviceProps} from './device';\n\n/**\n * Create and attach devices for a specific backend.\n */\nexport abstract class Adapter {\n  // new (props: DeviceProps): Device; Constructor isn't used\n  abstract type: string;\n  /** Check if this backend is supported */\n  abstract isSupported(): boolean;\n  /** Check if the given handle is a valid device handle for this backend */\n  abstract isDeviceHandle(handle: unknown): boolean;\n  /** Create a new device for this backend */\n  abstract create(props: DeviceProps): Promise<Device>;\n  /** Attach a Device to a valid handle for this backend (GPUDevice, WebGL2RenderingContext etc) */\n  abstract attach(handle: unknown, props: DeviceProps): Promise<Device>;\n\n  /**\n   * Page load promise\n   * Resolves when the DOM is loaded.\n   * @note Since are be limitations on number of `load` event listeners,\n   * it is recommended avoid calling this accessor until actually needed.\n   * I.e. we don't call it unless you know that you will be looking up a string in the DOM.\n   */\n  get pageLoaded(): Promise<void> {\n    return getPageLoadPromise();\n  }\n}\n\n// HELPER FUNCTIONS\n\nconst isPage: boolean = isBrowser() && typeof document !== 'undefined';\nconst isPageLoaded: () => boolean = () => isPage && document.readyState === 'complete';\nlet pageLoadPromise: Promise<void> | null = null;\n\n/** Returns a promise that resolves when the page is loaded */\nfunction getPageLoadPromise(): Promise<void> {\n  if (!pageLoadPromise) {\n    if (isPageLoaded() || typeof window === 'undefined') {\n      pageLoadPromise = Promise.resolve();\n    } else {\n      pageLoadPromise = new Promise(resolve => window.addEventListener('load', () => resolve()));\n    }\n  }\n  return pageLoadPromise;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isBrowser} from '@probe.gl/env';\nimport type {Device} from './device';\nimport type {Framebuffer} from './resources/framebuffer';\nimport type {TextureFormatDepthStencil} from '../shadertypes/textures/texture-formats';\nimport {uid} from '../utils/uid';\nimport {withResolvers} from '../utils/promise-utils';\n\n/** Properties for a CanvasContext */\nexport type CanvasContextProps = {\n  /** Identifier, for debugging */\n  id?: string;\n  /** If a canvas not supplied, one will be created and added to the DOM. If a string, a canvas with that id will be looked up in the DOM */\n  canvas?: HTMLCanvasElement | OffscreenCanvas | string | null;\n  /** If new canvas is created, it will be created in the specified container, otherwise is appended as a child of document.body */\n  container?: HTMLElement | string | null;\n  /** Width in pixels of the canvas - used when creating a new canvas */\n  width?: number;\n  /** Height in pixels of the canvas - used when creating a new canvas */\n  height?: number;\n  /** Visibility (only used if new canvas is created). */\n  visible?: boolean;\n  /** Whether to size the drawing buffer to the pixel size during auto resize. If a number is provided it is used as a static pixel ratio */\n  useDevicePixels?: boolean | number;\n  /** Whether to track window resizes. */\n  autoResize?: boolean;\n  /** @see https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#alphamode */\n  alphaMode?: 'opaque' | 'premultiplied';\n  /** @see https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#colorspace */\n  colorSpace?: 'srgb'; // GPUPredefinedColorSpace\n  /** Whether to track position changes. Calls this.device.onPositionChange */\n  trackPosition?: boolean;\n};\n\nexport type MutableCanvasContextProps = {\n  /** Whether to size the drawing buffer to the pixel size during auto resize. If a number is provided it is used as a static pixel ratio */\n  useDevicePixels?: boolean | number;\n};\n\n/**\n * Manages a canvas. Supports both HTML or offscreen canvas\n * - Creates a new canvas or looks up a canvas from the DOM\n * - Provides check for DOM loaded\n * @todo commit() @see https://github.com/w3ctag/design-reviews/issues/288\n * @todo transferControlToOffscreen: @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen\n */\nexport abstract class CanvasContext {\n  static isHTMLCanvas(canvas: unknown): canvas is HTMLCanvasElement {\n    return typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement;\n  }\n\n  static isOffscreenCanvas(canvas: unknown): canvas is OffscreenCanvas {\n    return typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas;\n  }\n\n  static defaultProps: Required<CanvasContextProps> = {\n    id: undefined!,\n    canvas: null,\n    width: 800,\n    height: 600,\n    useDevicePixels: true,\n    autoResize: true,\n    container: null,\n    visible: true,\n    alphaMode: 'opaque',\n    colorSpace: 'srgb',\n    trackPosition: false\n  };\n\n  abstract readonly device: Device;\n  abstract readonly handle: unknown;\n  readonly id: string;\n\n  readonly props: Required<CanvasContextProps>;\n  readonly canvas: HTMLCanvasElement | OffscreenCanvas;\n  /** Handle to HTML canvas */\n  readonly htmlCanvas?: HTMLCanvasElement;\n  /** Handle to wrapped OffScreenCanvas */\n  readonly offscreenCanvas?: OffscreenCanvas;\n  readonly type: 'html-canvas' | 'offscreen-canvas' | 'node';\n\n  /** Promise that resolved once the resize observer has updated the pixel size */\n  initialized: Promise<void>;\n  isInitialized: boolean = false;\n\n  /** Visibility is automatically updated (via an IntersectionObserver) */\n  isVisible: boolean = true;\n\n  /** Width of canvas in CSS units (tracked by a ResizeObserver) */\n  cssWidth: number;\n  /** Height of canvas in CSS units (tracked by a ResizeObserver) */\n  cssHeight: number;\n\n  /** Device pixel ratio. Automatically updated via media queries */\n  devicePixelRatio: number;\n  /** Exact width of canvas in physical pixels (tracked by a ResizeObserver) */\n  devicePixelWidth: number;\n  /** Exact height of canvas in physical pixels (tracked by a ResizeObserver) */\n  devicePixelHeight: number;\n\n  /** Width of drawing buffer: automatically tracks this.pixelWidth if props.autoResize is true */\n  drawingBufferWidth: number;\n  /** Height of drawing buffer: automatically tracks this.pixelHeight if props.autoResize is true */\n  drawingBufferHeight: number;\n\n  protected _initializedResolvers = withResolvers<void>();\n  protected readonly _resizeObserver: ResizeObserver | undefined;\n  protected readonly _intersectionObserver: IntersectionObserver | undefined;\n  protected _position: [number, number];\n  protected destroyed = false;\n\n  abstract get [Symbol.toStringTag](): string;\n\n  toString(): string {\n    return `${this[Symbol.toStringTag]}(${this.id})`;\n  }\n\n  constructor(props?: CanvasContextProps) {\n    this.props = {...CanvasContext.defaultProps, ...props};\n    props = this.props;\n\n    this.initialized = this._initializedResolvers.promise;\n\n    // Create a canvas element if needed\n    if (!isBrowser()) {\n      // TODO - does this prevent app from using jsdom style polyfills?\n      this.canvas = {width: props.width || 1, height: props.height || 1} as OffscreenCanvas;\n    } else if (!props.canvas) {\n      this.canvas = createCanvasElement(props);\n    } else if (typeof props.canvas === 'string') {\n      this.canvas = getCanvasFromDOM(props.canvas);\n    } else {\n      this.canvas = props.canvas;\n    }\n\n    if (CanvasContext.isHTMLCanvas(this.canvas)) {\n      this.id = props.id || this.canvas.id;\n      this.type = 'html-canvas';\n      this.htmlCanvas = this.canvas;\n    } else if (CanvasContext.isOffscreenCanvas(this.canvas)) {\n      this.id = props.id || 'offscreen-canvas';\n      this.type = 'offscreen-canvas';\n      this.offscreenCanvas = this.canvas;\n    } else {\n      // TODO - Node.js support is currently untested (was used for headless-gl in luma v8)\n      this.id = props.id || 'node-canvas-context';\n      this.type = 'node';\n    }\n\n    // Initialize size variables to some sane values (these will be updated by ResizeObserver)\n    this.cssWidth = this.htmlCanvas?.clientWidth || this.canvas.width;\n    this.cssHeight = this.htmlCanvas?.clientHeight || this.canvas.height;\n    this.devicePixelWidth = this.canvas.width;\n    this.devicePixelHeight = this.canvas.height;\n    this.drawingBufferWidth = this.canvas.width;\n    this.drawingBufferHeight = this.canvas.height;\n    this.devicePixelRatio = globalThis.devicePixelRatio || 1;\n    this._position = [0, 0];\n\n    if (CanvasContext.isHTMLCanvas(this.canvas)) {\n      // Track visibility changes\n      this._intersectionObserver = new IntersectionObserver(entries =>\n        this._handleIntersection(entries)\n      );\n      this._intersectionObserver.observe(this.canvas);\n\n      // Track size changes\n      this._resizeObserver = new ResizeObserver(entries => this._handleResize(entries));\n      try {\n        this._resizeObserver.observe(this.canvas, {box: 'device-pixel-content-box'});\n      } catch {\n        // Safari fallback\n        this._resizeObserver.observe(this.canvas, {box: 'content-box'});\n      }\n\n      // Track device pixel ratio changes.\n      // Defer call to after construction completes to ensure `this.device` is available.\n      setTimeout(() => this._observeDevicePixelRatio(), 0);\n\n      // Track top/left position changes\n      if (this.props.trackPosition) {\n        this._trackPosition();\n      }\n    }\n  }\n\n  destroy() {\n    this.destroyed = true;\n  }\n\n  setProps(props: MutableCanvasContextProps): this {\n    if ('useDevicePixels' in props) {\n      this.props.useDevicePixels = props.useDevicePixels || false;\n      this._updateDrawingBufferSize();\n    }\n    return this;\n  }\n\n  /** Returns a framebuffer with properly resized current 'swap chain' textures */\n  abstract getCurrentFramebuffer(options?: {\n    depthStencilFormat?: TextureFormatDepthStencil | false;\n  }): Framebuffer;\n\n  // SIZE METHODS\n\n  /**\n   * Returns the size covered by the canvas in CSS pixels\n   * @note This can be different from the actual device pixel size of a canvas due to DPR scaling, and rounding to integer pixels\n   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).\n   */\n  getCSSSize(): [number, number] {\n    return [this.cssWidth, this.cssHeight];\n  }\n\n  getPosition() {\n    return this._position;\n  }\n\n  /**\n   * Returns the size covered by the canvas in actual device pixels.\n   * @note This can be different from the 'CSS' size of a canvas due to DPR scaling, and rounding to integer pixels\n   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).\n   */\n  getDevicePixelSize(): [number, number] {\n    return [this.devicePixelWidth, this.devicePixelHeight];\n  }\n\n  /** Get the drawing buffer size (number of pixels GPU is rendering into, can be different from CSS size) */\n  getDrawingBufferSize(): [number, number] {\n    return [this.drawingBufferWidth, this.drawingBufferHeight];\n  }\n\n  /** Returns the biggest allowed framebuffer size. @todo Allow the application to limit this? */\n  getMaxDrawingBufferSize(): [number, number] {\n    const maxTextureDimension = this.device.limits.maxTextureDimension2D;\n    return [maxTextureDimension, maxTextureDimension];\n  }\n\n  /** Update the canvas drawing buffer size. Called automatically if props.autoResize is true. */\n  setDrawingBufferSize(width: number, height: number) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n\n    this.drawingBufferWidth = width;\n    this.drawingBufferHeight = height;\n  }\n\n  /**\n   * Returns the current DPR (number of physical pixels per CSS pixel), if props.useDevicePixels is true\n   * @note This can be a fractional (non-integer) number, e.g. when the user zooms in the browser.\n   * @note This function handles the non-HTML canvas cases\n   */\n  getDevicePixelRatio(): number {\n    const dpr = typeof window !== 'undefined' && window.devicePixelRatio;\n    return dpr || 1;\n  }\n\n  // DEPRECATED METHODS\n\n  /**\n   * Maps CSS pixel position to device pixel position\n   */\n  cssToDevicePixels(\n    cssPixel: [number, number],\n    yInvert: boolean = true\n  ): {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  } {\n    const ratio = this.cssToDeviceRatio();\n    const [width, height] = this.getDrawingBufferSize();\n    return scalePixels(cssPixel, ratio, width, height, yInvert);\n  }\n\n  /** @deprecated - use .getDevicePixelSize() */\n  getPixelSize() {\n    return this.getDevicePixelSize();\n  }\n\n  /** @deprecated - TODO which values should we use for aspect */\n  getAspect(): number {\n    const [width, height] = this.getDevicePixelSize();\n    return width / height;\n  }\n\n  /** @deprecated Returns multiplier need to convert CSS size to Device size */\n  cssToDeviceRatio(): number {\n    try {\n      const [drawingBufferWidth] = this.getDrawingBufferSize();\n      const [cssWidth] = this.getCSSSize();\n      return cssWidth ? drawingBufferWidth / cssWidth : 1;\n    } catch {\n      return 1;\n    }\n  }\n\n  /** @deprecated Use canvasContext.setDrawingBufferSize() */\n  resize(size: {width: number; height: number}): void {\n    this.setDrawingBufferSize(size.width, size.height);\n  }\n\n  // SUBCLASS OVERRIDES\n\n  /**\n   * Performs platform specific updates (WebGPU vs WebGL)\n   * Can be called after changes to size or props,\n   * to give implementation an opportunity to update configurations.\n   */\n  protected abstract _updateDevice(): void;\n\n  // IMPLEMENTATION\n\n  /**\n   * Allows subclass constructor to override the canvas id for auto created canvases.\n   * This can really help when debugging DOM in apps that create multiple devices\n   */\n  protected _setAutoCreatedCanvasId(id: string) {\n    if (this.htmlCanvas?.id === 'lumagl-auto-created-canvas') {\n      this.htmlCanvas.id = id;\n    }\n  }\n\n  /** reacts to an observed intersection */\n  protected _handleIntersection(entries: IntersectionObserverEntry[]) {\n    const entry = entries.find(entry_ => entry_.target === this.canvas);\n    if (!entry) {\n      return;\n    }\n    // TODO - store intersection rectangle?\n    const isVisible = entry.isIntersecting;\n    if (this.isVisible !== isVisible) {\n      this.isVisible = isVisible;\n      this.device.props.onVisibilityChange(this);\n    }\n  }\n\n  /**\n   * Reacts to an observed resize by using the most accurate pixel size information the browser can provide\n   * @see https://web.dev/articles/device-pixel-content-box\n   * @see https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html\n   */\n  protected _handleResize(entries: ResizeObserverEntry[]) {\n    const entry = entries.find(entry_ => entry_.target === this.canvas);\n    if (!entry) {\n      return;\n    }\n\n    // Update CSS size using content box size\n    this.cssWidth = entry.contentBoxSize[0].inlineSize;\n    this.cssHeight = entry.contentBoxSize[0].blockSize;\n\n    // Update our drawing buffer size variables, saving the old values for logging\n    const oldPixelSize = this.getDevicePixelSize();\n\n    // Use the most accurate drawing buffer size information the current browser can provide\n    // Note: content box sizes are guaranteed to be integers\n    // Note: Safari falls back to contentBoxSize\n    const devicePixelWidth =\n      entry.devicePixelContentBoxSize?.[0].inlineSize ||\n      entry.contentBoxSize[0].inlineSize * devicePixelRatio;\n\n    const devicePixelHeight =\n      entry.devicePixelContentBoxSize?.[0].blockSize ||\n      entry.contentBoxSize[0].blockSize * devicePixelRatio;\n\n    // Make sure we don't overflow the maximum supported texture size\n    const [maxDevicePixelWidth, maxDevicePixelHeight] = this.getMaxDrawingBufferSize();\n    this.devicePixelWidth = Math.max(1, Math.min(devicePixelWidth, maxDevicePixelWidth));\n    this.devicePixelHeight = Math.max(1, Math.min(devicePixelHeight, maxDevicePixelHeight));\n\n    this._updateDrawingBufferSize();\n\n    // Inform the device\n    this.device.props.onResize(this, {oldPixelSize});\n  }\n\n  protected _updateDrawingBufferSize() {\n    // Update the canvas drawing buffer size\n    if (this.props.autoResize) {\n      if (typeof this.props.useDevicePixels === 'number') {\n        const dpr = this.props.useDevicePixels;\n        this.setDrawingBufferSize(this.cssWidth * dpr, this.cssHeight * dpr);\n      } else if (this.props.useDevicePixels) {\n        this.setDrawingBufferSize(this.devicePixelWidth, this.devicePixelHeight);\n      } else {\n        this.setDrawingBufferSize(this.cssWidth, this.cssHeight);\n      }\n\n      // Inform the subclass\n      this._updateDevice();\n    }\n\n    // Resolve the initialized promise\n    this._initializedResolvers.resolve();\n    this.isInitialized = true;\n\n    this.updatePosition();\n  }\n\n  /** Monitor DPR changes */\n  _observeDevicePixelRatio() {\n    const oldRatio = this.devicePixelRatio;\n    this.devicePixelRatio = window.devicePixelRatio;\n\n    this.updatePosition();\n\n    // Inform the device\n    this.device.props.onDevicePixelRatioChange(this, {oldRatio});\n    // Set up a one time query against the current resolution.\n    matchMedia(`(resolution: ${this.devicePixelRatio}dppx)`).addEventListener(\n      'change',\n      () => this._observeDevicePixelRatio(),\n      {once: true}\n    );\n  }\n\n  /** Start tracking positions with a timer */\n  _trackPosition(intervalMs: number = 100): void {\n    const intervalId = setInterval(() => {\n      if (this.destroyed) {\n        clearInterval(intervalId);\n      } else {\n        this.updatePosition();\n      }\n    }, intervalMs);\n  }\n\n  /**\n   * Calculated the absolute position of the canvas\n   * @note - getBoundingClientRect() is normally cheap but can be expensive\n   * if called before browser has finished a reflow. Should not be the case here.\n   */\n  updatePosition() {\n    const newRect = this.htmlCanvas?.getBoundingClientRect();\n    if (newRect) {\n      // We only track position since we rely on the more precise ResizeObserver for size\n      const position: [number, number] = [newRect.left, newRect.top];\n      this._position ??= position;\n      const positionChanged =\n        position[0] !== this._position[0] || position[1] !== this._position[1];\n      if (positionChanged) {\n        const oldPosition = this._position;\n        this._position = position;\n        this.device.props.onPositionChange?.(this, {oldPosition});\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/** Get a container element from a string or DOM element */\nfunction getContainer(container: HTMLElement | string | null): HTMLElement {\n  if (typeof container === 'string') {\n    const element = document.getElementById(container);\n    if (!element) {\n      throw new Error(`${container} is not an HTML element`);\n    }\n    return element;\n  }\n  if (container) {\n    return container;\n  }\n  return document.body;\n}\n\n/** Get a Canvas element from DOM id */\nfunction getCanvasFromDOM(canvasId: string): HTMLCanvasElement {\n  const canvas = document.getElementById(canvasId);\n  if (!CanvasContext.isHTMLCanvas(canvas)) {\n    throw new Error('Object is not a canvas element');\n  }\n  return canvas;\n}\n\n/** Create a new canvas */\nfunction createCanvasElement(props: CanvasContextProps) {\n  const {width, height} = props;\n  const newCanvas = document.createElement('canvas');\n  newCanvas.id = uid('lumagl-auto-created-canvas');\n  newCanvas.width = width || 1;\n  newCanvas.height = height || 1;\n  newCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  newCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  if (!props?.visible) {\n    newCanvas.style.visibility = 'hidden';\n  }\n  // Insert the canvas in the DOM\n  const container = getContainer(props?.container || null);\n  container.insertBefore(newCanvas, container.firstChild);\n\n  return newCanvas;\n}\n\n/**\n * Scales pixels linearly, handles edge cases\n * @param pixel\n * @param ratio\n * @param width\n * @param height\n * @param yInvert\n * @returns\n */\nfunction scalePixels(\n  pixel: [number, number],\n  ratio: number,\n  width: number,\n  height: number,\n  yInvert: boolean\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n} {\n  const point = pixel;\n\n  const x = scaleX(point[0], ratio, width);\n  let y = scaleY(point[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locations\n\n  let t = scaleX(point[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(point[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x: number, ratio: number, width: number): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y: number, ratio: number, height: number, yInvert: boolean): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TODO - replace with Promise.withResolvers once we upgrade TS baseline\nexport function withResolvers<T>(): {\n  promise: Promise<T>;\n  resolve: (t: T) => void;\n  reject: (error: Error) => void;\n} {\n  let resolve: (t: T) => void;\n  let reject: (error: Error) => void;\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  // @ts-expect-error - in fact these are no used before initialized\n  return {promise, resolve, reject};\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {CompareFunction} from '../types/parameters';\nimport {Resource, ResourceProps} from './resource';\n\n/** Edge values sampling mode */\nexport type SamplerAddressMode = 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n\n/** Sampler filtering mode */\nexport type SamplerFilterMode = 'nearest' | 'linear';\n\n/**\n * Properties for initializing a sampler\n */\nexport type SamplerProps = ResourceProps & {\n  /** Comparison / shadow samplers are used with depth textures. See the `Sampler.compare` field */\n  type?: 'color-sampler' | 'comparison-sampler';\n  /** Edge value sampling in X direction */\n  addressModeU?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n  /** Edge value sampling in Y direction */\n  addressModeV?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n  /** Edge value sampling in Z direction */\n  addressModeW?: 'clamp-to-edge' | 'repeat' | 'mirror-repeat';\n\n  /** Magnification: the area of the fragment in texture space is smaller than a texel */\n  magFilter?: 'nearest' | 'linear';\n  /** Minification: the area of the fragment in texture space is larger than a texel */\n  minFilter?: 'nearest' | 'linear';\n  /** mipmapping: select between multiple mipmaps based on angle and size of the texture relative to the screen. */\n  mipmapFilter?: 'none' | 'nearest' | 'linear';\n  /** Affects the mipmap image selection */\n  lodMinClamp?: number;\n  /** Affects the mipmap image selection */\n  lodMaxClamp?: number;\n  /** Maximum number of samples that can be taken of the texture during any one texture fetch */\n  maxAnisotropy?: number;\n  /** How to compare reference values provided in shader shadow sampler calls with those pulled from the texture */\n  compare?: CompareFunction;\n};\n\nexport type SamplerParameters = Omit<SamplerProps, keyof ResourceProps>;\n\n/** Immutable Sampler object */\nexport abstract class Sampler extends Resource<SamplerProps> {\n  static override defaultProps: Required<SamplerProps> = {\n    ...Resource.defaultProps,\n    type: 'color-sampler',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge',\n    addressModeW: 'clamp-to-edge',\n    magFilter: 'nearest',\n    minFilter: 'nearest',\n    mipmapFilter: 'none',\n    lodMinClamp: 0,\n    lodMaxClamp: 32, // Per WebGPU spec\n    compare: 'less-equal',\n    maxAnisotropy: 1\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Sampler';\n  }\n\n  constructor(device: Device, props: SamplerProps) {\n    props = Sampler.normalizeProps(device, props);\n    super(device, props, Sampler.defaultProps);\n  }\n\n  protected static normalizeProps(device: Device, props: SamplerProps): SamplerProps {\n    return props;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TypedArray} from '@math.gl/types';\nimport type {Device} from '../device';\nimport type {TextureFormat} from '../../shadertypes/textures/texture-formats';\nimport type {TextureView, TextureViewProps} from './texture-view';\nimport {Resource, ResourceProps} from './resource';\nimport {Sampler, SamplerProps} from './sampler';\nimport {ExternalImage} from '../../image-utils/image-types';\nimport {log} from '../../utils/log';\n\n/** Options for Texture.copyExternalImage */\nexport type CopyExternalImageOptions = {\n  /** Image */\n  image: ExternalImage;\n  /** Copy from image x offset (default 0) */\n  sourceX?: number;\n  /** Copy from image y offset (default 0) */\n  sourceY?: number;\n  /** Copy area width (default 1) */\n  width?: number;\n  /** Copy area height (default 1) */\n  height?: number;\n  /** Copy depth, number of layers/depth slices(default 1) */\n  depth?: number;\n  /** Start copying into offset x (default 0) */\n  x?: number;\n  /** Start copying into offset y (default 0) */\n  y?: number;\n  /** Start copying into layer / depth slice z (default 0) */\n  z?: number;\n  /** Which mip-level to copy into (default 0) */\n  mipLevel?: number;\n  /** When copying into depth stencil textures (default 'all') */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  /** Specific color space of image data */\n  colorSpace?: 'srgb';\n  /** load as premultiplied alpha  */\n  premultipliedAlpha?: boolean;\n  /** Whether to flip the image vertically */\n  flipY?: boolean;\n};\n\n/** Options for copyImageData */\nexport type CopyImageDataOptions = {\n  /** Data to copy (array of bytes) */\n  data: ArrayBuffer | SharedArrayBuffer | ArrayBufferView;\n  /** Offset into the data (in addition to any offset built-in to the ArrayBufferView) */\n  byteOffset?: number;\n  /** The stride, in bytes, between the beginning of each texel block row and the subsequent texel block row. Required if there are multiple texel block rows (i.e. the copy height or depth is more than one block). */\n  bytesPerRow?: number;\n  /** Number or rows per image (needed if multiple images are being set) */\n  rowsPerImage?: number;\n  /** Start copying into offset x (default 0) */\n  x?: number;\n  /** Start copying into offset y (default 0) */\n  y?: number;\n  /** Start copying from depth layer z (default 0) */\n  z?: number;\n  /** Which mip-level to copy into (default 0) */\n  mipLevel?: number;\n  /** When copying into depth stencil textures (default 'all') */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n};\n\nconst BASE_DIMENSIONS: Record<string, '1d' | '2d' | '3d'> = {\n  '1d': '1d',\n  '2d': '2d',\n  '2d-array': '2d',\n  cube: '2d',\n  'cube-array': '2d',\n  '3d': '3d'\n};\n\n/** Texture properties */\nexport type TextureProps = ResourceProps & {\n  /** @deprecated Use AsyncTexture to create textures with data. */\n  data?: ExternalImage | TypedArray | null;\n  /** Dimension of this texture. Defaults to '2d' */\n  dimension?: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** The format (bit layout) of the textures pixel data */\n  format?: TextureFormat;\n  /** Width in texels */\n  width: number;\n  /** Width in texels */\n  height: number;\n  /** Number of depth layers */\n  depth?: number;\n  /** How this texture will be used. Defaults to TEXTURE | COPY_DST | RENDER_ATTACHMENT */\n  usage?: number;\n  /** How many mip levels */\n  mipLevels?: number;\n  /** Multi sampling */\n  samples?: number;\n\n  /** Sampler (or SamplerProps) for the default sampler for this texture. Used if no sampler provided. Note that other samplers can still be used. */\n  sampler?: Sampler | SamplerProps;\n  /** Props for the default TextureView for this texture. Note that other views can still be created and used. */\n  view?: TextureViewProps;\n};\n\n/**\n * Abstract Texture interface\n * Texture Object\n * https://gpuweb.github.io/gpuweb/#gputexture\n */\nexport abstract class Texture extends Resource<TextureProps> {\n  /** The texture can be bound for use as a sampled texture in a shader */\n  static SAMPLE = 0x04;\n  /** The texture can be bound for use as a storage texture in a shader */\n  static STORAGE = 0x08;\n  /** The texture can be used as a color or depth/stencil attachment in a render pass */\n  static RENDER = 0x10;\n  /** The texture can be used as the source of a copy operation */\n  static COPY_SRC = 0x01;\n  /** he texture can be used as the destination of a copy or write operation */\n  static COPY_DST = 0x02;\n\n  /** @deprecated Use Texture.SAMPLE */\n  static TEXTURE = 0x04;\n  /** @deprecated Use Texture.RENDER */\n  static RENDER_ATTACHMENT = 0x10;\n\n  /** dimension of this texture */\n  readonly dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** base dimension of this texture */\n  readonly baseDimension: '1d' | '2d' | '3d';\n  /** format of this texture */\n  readonly format: TextureFormat;\n  /** width in pixels of this texture */\n  width: number;\n  /** height in pixels of this texture */\n  height: number;\n  /** depth of this texture */\n  depth: number;\n  /** mip levels in this texture */\n  mipLevels: number;\n  /** Default sampler for this texture */\n  abstract sampler: Sampler;\n  /** Default view for this texture */\n  abstract view: TextureView;\n\n  /** \"Time\" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */\n  updateTimestamp: number;\n\n  override get [Symbol.toStringTag](): string {\n    return 'Texture';\n  }\n\n  override toString(): string {\n    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;\n  }\n\n  /** Do not use directly. Create with device.createTexture() */\n  constructor(device: Device, props: TextureProps) {\n    props = Texture.normalizeProps(device, props);\n    super(device, props, Texture.defaultProps);\n    this.dimension = this.props.dimension;\n    this.baseDimension = BASE_DIMENSIONS[this.dimension];\n    this.format = this.props.format;\n\n    // Size\n    this.width = this.props.width;\n    this.height = this.props.height;\n    this.depth = this.props.depth;\n    this.mipLevels = this.props.mipLevels;\n\n    // Calculate size, if not provided\n    if (this.props.width === undefined || this.props.height === undefined) {\n      if (device.isExternalImage(props.data)) {\n        const size = device.getExternalImageSize(props.data);\n        this.width = size?.width || 1;\n        this.height = size?.height || 1;\n      } else {\n        this.width = 1;\n        this.height = 1;\n        if (this.props.width === undefined || this.props.height === undefined) {\n          log.warn(\n            `${this} created with undefined width or height. This is deprecated. Use AsyncTexture instead.`\n          )();\n        }\n      }\n    }\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /** Set sampler props associated with this texture */\n  setSampler(sampler: Sampler | SamplerProps): void {\n    this.sampler = sampler instanceof Sampler ? sampler : this.device.createSampler(sampler);\n  }\n  /** Create a texture view for this texture */\n  abstract createView(props: TextureViewProps): TextureView;\n  /** Copy an image (e.g an ImageBitmap) into the texture */\n  abstract copyExternalImage(options: CopyExternalImageOptions): {width: number; height: number};\n  /** Copy raw image data (bytes) into the texture */\n  abstract copyImageData(options: CopyImageDataOptions): void;\n  /** Generate mipmaps (WebGL only) */\n  abstract generateMipmapsWebGL(): void;\n\n  /**\n   * Create a new texture with the same parameters and optionally a different size\n   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   */\n  clone(size?: {width: number; height: number}): Texture {\n    return this.device.createTexture({...this.props, ...size});\n  }\n\n  /** Ensure we have integer coordinates */\n  protected static normalizeProps(device: Device, props: TextureProps): TextureProps {\n    const newProps = {...props};\n\n    // Ensure we have integer coordinates\n    const {width, height} = newProps;\n    if (typeof width === 'number') {\n      newProps.width = Math.max(1, Math.ceil(width));\n    }\n    if (typeof height === 'number') {\n      newProps.height = Math.max(1, Math.ceil(height));\n    }\n    return newProps;\n  }\n\n  // HELPERS\n\n  /** Initialize texture with supplied props */\n  // eslint-disable-next-line max-statements\n  _initializeData(data: TextureProps['data']): void {\n    // Store opts for accessors\n\n    if (this.device.isExternalImage(data)) {\n      this.copyExternalImage({\n        image: data,\n        width: this.width,\n        height: this.height,\n        depth: this.depth,\n        mipLevel: 0,\n        x: 0,\n        y: 0,\n        z: 0,\n        aspect: 'all',\n        colorSpace: 'srgb',\n        premultipliedAlpha: false,\n        flipY: false\n      });\n    } else if (data) {\n      this.copyImageData({\n        data,\n        // width: this.width,\n        // height: this.height,\n        // depth: this.depth,\n        mipLevel: 0,\n        x: 0,\n        y: 0,\n        z: 0,\n        aspect: 'all'\n      });\n    }\n  }\n\n  _normalizeCopyImageDataOptions(options_: CopyImageDataOptions): Required<CopyImageDataOptions> {\n    const {width, height, depth} = this;\n    const options = {...Texture.defaultCopyDataOptions, width, height, depth, ...options_};\n\n    const info = this.device.getTextureFormatInfo(this.format);\n    if (!options_.bytesPerRow && !info.bytesPerPixel) {\n      throw new Error(`bytesPerRow must be provided for texture format ${this.format}`);\n    }\n    options.bytesPerRow = options_.bytesPerRow || width * (info.bytesPerPixel || 4);\n    options.rowsPerImage = options_.rowsPerImage || height;\n\n    // WebGL will error if we try to copy outside the bounds of the texture\n    // options.width = Math.min(options.width, this.width - options.x);\n    // options.height = Math.min(options.height, this.height - options.y);\n    return options;\n  }\n\n  _normalizeCopyExternalImageOptions(\n    options_: CopyExternalImageOptions\n  ): Required<CopyExternalImageOptions> {\n    const size = this.device.getExternalImageSize(options_.image);\n    const options = {...Texture.defaultCopyExternalImageOptions, ...size, ...options_};\n    // WebGL will error if we try to copy outside the bounds of the texture\n    options.width = Math.min(options.width, this.width - options.x);\n    options.height = Math.min(options.height, this.height - options.y);\n    return options;\n  }\n\n  /** Default options */\n  static override defaultProps: Required<TextureProps> = {\n    ...Resource.defaultProps,\n    data: null,\n    dimension: '2d',\n    format: 'rgba8unorm',\n    usage: Texture.TEXTURE | Texture.RENDER_ATTACHMENT | Texture.COPY_DST,\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipLevels: 1,\n    samples: undefined!,\n    sampler: {},\n    view: undefined!\n  };\n\n  protected static defaultCopyDataOptions: Required<CopyImageDataOptions> = {\n    data: undefined!,\n    byteOffset: 0,\n    bytesPerRow: undefined!,\n    rowsPerImage: undefined!,\n    mipLevel: 0,\n    x: 0,\n    y: 0,\n    z: 0,\n    aspect: 'all'\n  };\n\n  /** Default options */\n  protected static defaultCopyExternalImageOptions: Required<CopyExternalImageOptions> = {\n    image: undefined!,\n    sourceX: 0,\n    sourceY: 0,\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipLevel: 0,\n    x: 0,\n    y: 0,\n    z: 0,\n    aspect: 'all',\n    colorSpace: 'srgb',\n    premultipliedAlpha: false,\n    flipY: false\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {Texture} from './texture';\nimport type {TextureFormat} from '../../shadertypes/textures/texture-formats';\nimport {Resource, ResourceProps} from './resource';\n\n/** Properties for initializing a texture view */\nexport type TextureViewProps = ResourceProps & {\n  /** The format of the texture view. Must be either the format of the texture or one of the viewFormats specified during its creation. */\n  format?: TextureFormat;\n  /** The dimension to view the texture as. */\n  dimension?: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** Which aspect(s) of the texture are accessible to the texture view. default \"all\"*/\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  /** The first (most detailed) mipmap level accessible to the texture view.  default 0*/\n  baseMipLevel?: number;\n  /** How many mipmap levels, starting with baseMipLevel, are accessible to the texture view. */\n  mipLevelCount: number;\n  /** The index of the first array layer accessible to the texture view. default 0 */\n  baseArrayLayer?: number;\n  /** How many array layers, starting with baseArrayLayer, are accessible to the texture view. */\n  arrayLayerCount: number;\n};\n\n/** Immutable TextureView object */\nexport abstract class TextureView extends Resource<TextureViewProps> {\n  abstract texture: Texture;\n\n  override get [Symbol.toStringTag](): string {\n    return 'TextureView';\n  }\n\n  /** Should not be constructed directly. Use `texture.createView(props)` */\n  constructor(device: Device, props: TextureViewProps & {texture: Texture}) {\n    super(device, props, TextureView.defaultProps);\n  }\n\n  static override defaultProps: Required<TextureViewProps> = {\n    ...Resource.defaultProps,\n    format: undefined!,\n    dimension: undefined!,\n    aspect: 'all',\n    baseMipLevel: 0,\n    mipLevelCount: undefined!,\n    baseArrayLayer: 0,\n    arrayLayerCount: undefined!\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\nexport type ExternalTextureProps = ResourceProps & {\n  source: HTMLVideoElement; //  | null;\n  colorSpace?: 'srgb';\n};\nexport abstract class ExternalTexture extends Resource<ExternalTextureProps> {\n  override get [Symbol.toStringTag](): string {\n    return 'ExternalTexture';\n  }\n\n  constructor(device: Device, props: ExternalTextureProps) {\n    super(device, props, ExternalTexture.defaultProps);\n  }\n\n  static override defaultProps: Required<ExternalTextureProps> = {\n    ...Resource.defaultProps,\n    source: undefined!,\n    colorSpace: 'srgb'\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {CompilerMessage} from '../adapter/types/compiler-message';\n\n/** @returns annotated errors or warnings */\nexport function formatCompilerLog(\n  shaderLog: readonly CompilerMessage[],\n  source: string,\n  options?: {\n    /** Include source code in the log. Either just the lines before issues or all source code */\n    showSourceCode?: 'no' | 'issues' | 'all';\n    html?: boolean;\n  }\n): string {\n  let formattedLog = '';\n  const lines = source.split(/\\r?\\n/);\n  const log = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);\n\n  switch (options?.showSourceCode || 'no') {\n    case 'all':\n      // Parse the error - note: browser and driver dependent\n      let currentMessage = 0;\n      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {\n        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);\n        while (log.length > currentMessage && log[currentMessage].lineNum === lineNum) {\n          const message = log[currentMessage++];\n          formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n            ...options,\n            inlineSource: false\n          });\n        }\n      }\n      // Print any remaining messages\n      while (log.length > currentMessage) {\n        const message = log[currentMessage++];\n        formattedLog += formatCompilerMessage(message, [], 0, {\n          ...options,\n          inlineSource: false\n        });\n      }\n      return formattedLog;\n\n    case 'issues':\n    case 'no':\n      // Parse the error - note: browser and driver dependent\n      for (const message of shaderLog) {\n        formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n          inlineSource: options?.showSourceCode !== 'no'\n        });\n      }\n      return formattedLog;\n  }\n}\n\n// Helpers\n\n/** Format one message */\nfunction formatCompilerMessage(\n  message: CompilerMessage,\n  lines: readonly string[],\n  lineNum: number,\n  options: {\n    inlineSource?: boolean;\n    html?: boolean;\n  }\n): string {\n  if (options?.inlineSource) {\n    const numberedLines = getNumberedLines(lines, lineNum);\n    // If we got error position on line add a `^^^` indicator on next line\n    const positionIndicator = message.linePos > 0 ? `${' '.repeat(message.linePos + 5)}^^^\\n` : '';\n    return `\n${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}\n\n`;\n  }\n  const color = message.type === 'error' ? 'red' : '#8B4000'; // dark orange\n  return options?.html\n    ? `<div class='luma-compiler-log-error' style=\"color:${color};\"><b> ${message.type.toUpperCase()}: ${\n        message.message\n      }</b></div>`\n    : `${message.type.toUpperCase()}: ${message.message}`;\n}\n\nfunction getNumberedLines(\n  lines: readonly string[],\n  lineNum: number,\n  options?: {html?: boolean}\n): string {\n  let numberedLines = '';\n  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {\n    const sourceLine = lines[lineIndex - 1];\n    if (sourceLine !== undefined) {\n      numberedLines += getNumberedLine(sourceLine, lineNum, options);\n    }\n  }\n  return numberedLines;\n}\n\nfunction getNumberedLine(line: string, lineNum: number, options?: {html?: boolean}): string {\n  const escapedLine = options?.html ? escapeHTML(line) : line;\n  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? '<br/>' : '\\n'}`;\n}\n\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string: string, paddedLength: number): string {\n  let result = '';\n  for (let i = string.length; i < paddedLength; ++i) {\n    result += ' ';\n  }\n  return result + string;\n}\n\nfunction escapeHTML(unsafe: string): string {\n  return unsafe\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;')\n    .replaceAll(\"'\", '&#039;');\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n// import { log } from '../../utils/log';\nimport {uid} from '../../utils/uid';\nimport {CompilerMessage} from '../types/compiler-message';\nimport {formatCompilerLog} from '../../adapter-utils/format-compiler-log';\n\n/**\n * Properties for a Shader\n */\nexport type ShaderProps = ResourceProps & {\n  /** Shader language (defaults to auto) */\n  language?: 'glsl' | 'wgsl' | 'auto';\n  /** Which stage are we compiling? Required for GLSL. Ignored for WGSL. */\n  stage?: 'vertex' | 'fragment' | 'compute';\n  /** Shader source code */\n  source: string;\n  /** Optional shader source map (WebGPU only) */\n  sourceMap?: string | null;\n  /** Optional shader entry point (WebGPU only) */\n  entryPoint?: string;\n  /** Show shader source in browser? Overrides the device.props.debugShaders setting */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n};\n\n/**\n * Immutable Shader object\n * In WebGPU the handle can be copied between threads\n */\nexport abstract class Shader extends Resource<ShaderProps> {\n  override get [Symbol.toStringTag](): string {\n    return 'Shader';\n  }\n\n  /** The stage of this shader */\n  readonly stage: 'vertex' | 'fragment' | 'compute';\n  /** The source code of this shader */\n  readonly source: string;\n  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */\n  compilationStatus: 'pending' | 'success' | 'error' = 'pending';\n\n  /** Create a new Shader instance */\n  constructor(device: Device, props: ShaderProps) {\n    props = {...props, debugShaders: props.debugShaders || device.props.debugShaders || 'errors'};\n    super(device, {id: getShaderIdFromProps(props), ...props}, Shader.defaultProps);\n    this.stage = this.props.stage;\n    this.source = this.props.source;\n  }\n\n  abstract get asyncCompilationStatus(): Promise<'pending' | 'success' | 'error'>;\n\n  /** Get compiler log asynchronously */\n  abstract getCompilationInfo(): Promise<readonly CompilerMessage[]>;\n\n  /** Get compiler log synchronously (WebGL only) */\n  getCompilationInfoSync(): readonly CompilerMessage[] | null {\n    return null;\n  }\n\n  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */\n  getTranslatedSource(): string | null {\n    return null;\n  }\n\n  // PORTABLE HELPERS\n\n  /** In browser logging of errors */\n  async debugShader(): Promise<void> {\n    const trigger = this.props.debugShaders;\n    switch (trigger) {\n      case 'never':\n        return;\n      case 'errors':\n        // On WebGL - Don't extract the log unless errors\n        if (this.compilationStatus === 'success') {\n          return;\n        }\n        break;\n      case 'warnings':\n      case 'always':\n        break;\n    }\n\n    const messages = await this.getCompilationInfo();\n    if (trigger === 'warnings' && messages?.length === 0) {\n      return;\n    }\n    this._displayShaderLog(messages, this.id);\n  }\n\n  // PRIVATE\n\n  /**\n   * In-browser UI logging of errors\n   * TODO - this HTML formatting code should not be in Device, should be pluggable\n   */\n  protected _displayShaderLog(messages: readonly CompilerMessage[], shaderId: string): void {\n    // Return if under Node.js / incomplete `document` polyfills\n    if (typeof document === 'undefined' || !document?.createElement) {\n      return;\n    }\n\n    const shaderName: string = shaderId; // getShaderName(this.source) || ;\n    const shaderTitle: string = `${this.stage} shader \"${shaderName}\"`;\n    let htmlLog = formatCompilerLog(messages, this.source, {showSourceCode: 'all', html: true});\n    // Show translated source if available\n    const translatedSource = this.getTranslatedSource();\n    if (translatedSource) {\n      htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style=\"user-select:text;\"><pre>${translatedSource}</pre></code>`;\n    }\n    // Make it clickable so we can copy to clipboard\n    const button = document.createElement('Button');\n    button.innerHTML = `\n<h1>Compilation error in ${shaderTitle}</h1><br /><br />\n<code style=\"user-select:text;\"><pre>\n${htmlLog}\n</pre></code>`;\n    button.style.top = '10px';\n    button.style.left = '10px';\n    button.style.position = 'absolute';\n    button.style.zIndex = '9999';\n    button.style.width = '100%';\n    button.style.textAlign = 'left';\n    document.body.appendChild(button);\n\n    const errors = document.getElementsByClassName('luma-compiler-log-error');\n    errors[0]?.scrollIntoView();\n\n    // TODO - add a small embedded copy button (instead of main button)\n    button.onclick = () => {\n      // const source = this.source.replaceAll('\\n', '<br />');\n      const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;\n      navigator.clipboard.writeText(dataURI);\n    };\n\n    // TODO - add a small embedded close button\n  }\n\n  static override defaultProps: Required<ShaderProps> = {\n    ...Resource.defaultProps,\n    language: 'auto',\n    stage: undefined!,\n    source: '',\n    sourceMap: null,\n    entryPoint: 'main',\n    debugShaders: undefined!\n  };\n}\n\n// HELPERS\n\n/** Deduce an id, from shader source, or supplied id, or shader type */\nfunction getShaderIdFromProps(props: ShaderProps): string {\n  return getShaderName(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);\n}\n\n/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */\nfunction getShaderName(shader: string, defaultName: string = 'unnamed'): string {\n  const SHADER_NAME_REGEXP = /#define[\\s*]SHADER_NAME[\\s*]([A-Za-z0-9_-]+)[\\s*]/;\n  const match = SHADER_NAME_REGEXP.exec(shader);\n  return match ? match[1] : defaultName;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  TextureFormatColor,\n  TextureFormatDepthStencil,\n  TextureFormat\n} from '../../shadertypes/textures/texture-formats';\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\nimport {Texture} from './texture';\nimport {TextureView} from './texture-view';\nimport {log} from '../../utils/log';\n\nexport type FramebufferProps = ResourceProps & {\n  width?: number;\n  height?: number;\n  colorAttachments?: (TextureView | Texture | TextureFormatColor)[];\n  depthStencilAttachment?: (TextureView | Texture | TextureFormatDepthStencil) | null;\n};\n\n/**\n * Create new textures with correct size for all attachments.\n * @note resize() destroys existing textures (if size has changed).\n */\nexport abstract class Framebuffer extends Resource<FramebufferProps> {\n  override get [Symbol.toStringTag](): string {\n    return 'Framebuffer';\n  }\n\n  /** Width of all attachments in this framebuffer */\n  width: number;\n  /** Height of all attachments in this framebuffer */\n  height: number;\n  /** Color attachments */\n  abstract colorAttachments: TextureView[];\n  /** Depth-stencil attachment, if provided */\n  abstract depthStencilAttachment: TextureView | null;\n\n  constructor(device: Device, props: FramebufferProps = {}) {\n    super(device, props, Framebuffer.defaultProps);\n    this.width = this.props.width;\n    this.height = this.props.height;\n  }\n\n  /**\n   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.\n   * @note Does not copy contents of the attached textures.\n   */\n  clone(size?: {width: number; height: number}): Framebuffer {\n    const colorAttachments = this.colorAttachments.map(colorAttachment =>\n      colorAttachment.texture.clone(size)\n    );\n\n    const depthStencilAttachment =\n      this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(size);\n\n    return this.device.createFramebuffer({...this.props, colorAttachments, depthStencilAttachment});\n  }\n\n  /**\n   * Resizes all attachments\n   * @note resize() destroys existing textures (if size has changed).\n   * @deprecated Use framebuffer.clone()\n   */\n  resize(size: {width: number; height: number}): void;\n  resize(size: [width: number, height: number]): void;\n  resize(): void;\n  resize(size?: {width: number; height: number} | [width: number, height: number]): void {\n    let updateSize: boolean = !size;\n    if (size) {\n      const [width, height] = Array.isArray(size) ? size : [size.width, size.height];\n      updateSize = updateSize || height !== this.height || width !== this.width;\n      this.width = width;\n      this.height = height;\n    }\n    if (updateSize) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();\n      this.resizeAttachments(this.width, this.height);\n    }\n  }\n\n  /** Auto creates any textures */\n  protected autoCreateAttachmentTextures(): void {\n    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {\n      throw new Error('Framebuffer has noattachments');\n    }\n\n    this.colorAttachments = this.props.colorAttachments.map((attachment, index) => {\n      if (typeof attachment === 'string') {\n        const texture = this.createColorTexture(attachment, index);\n        this.attachResource(texture);\n        return texture.view;\n      }\n      if (attachment instanceof Texture) {\n        return attachment.view;\n      }\n      return attachment;\n    });\n\n    const attachment = this.props.depthStencilAttachment;\n    if (attachment) {\n      if (typeof attachment === 'string') {\n        const texture = this.createDepthStencilTexture(attachment);\n        this.attachResource(texture);\n        this.depthStencilAttachment = texture.view;\n      } else if (attachment instanceof Texture) {\n        this.depthStencilAttachment = attachment.view;\n      } else {\n        this.depthStencilAttachment = attachment;\n      }\n    }\n  }\n\n  /** Create a color texture */\n  protected createColorTexture(format: TextureFormat, index: number): Texture {\n    return this.device.createTexture({\n      id: `${this.id}-color-attachment-${index}`,\n      usage: Texture.RENDER_ATTACHMENT,\n      format,\n      width: this.width,\n      height: this.height,\n      // TODO deprecated? - luma.gl v8 compatibility\n      sampler: {\n        magFilter: 'linear',\n        minFilter: 'linear'\n      }\n    });\n  }\n\n  /** Create depth stencil texture */\n  protected createDepthStencilTexture(format: TextureFormat): Texture {\n    return this.device.createTexture({\n      id: `${this.id}-depth-stencil-attachment`,\n      usage: Texture.RENDER_ATTACHMENT,\n      format,\n      width: this.width,\n      height: this.height\n    });\n  }\n\n  /**\n   * Default implementation of resize\n   * Creates new textures with correct size for all attachments.\n   * and destroys existing textures if owned\n   */\n  protected resizeAttachments(width: number, height: number): void {\n    for (let i = 0; i < this.colorAttachments.length; ++i) {\n      if (this.colorAttachments[i]) {\n        const resizedTexture = this.colorAttachments[i].texture.clone({\n          width,\n          height\n        });\n        this.destroyAttachedResource(this.colorAttachments[i]);\n        this.colorAttachments[i] = resizedTexture.view;\n        this.attachResource(resizedTexture.view);\n      }\n    }\n\n    if (this.depthStencilAttachment) {\n      const resizedTexture = this.depthStencilAttachment.texture.clone({\n        width,\n        height\n      });\n      this.destroyAttachedResource(this.depthStencilAttachment);\n      this.depthStencilAttachment = resizedTexture.view;\n      this.attachResource(resizedTexture);\n    }\n\n    this.updateAttachments();\n  }\n\n  /** Implementation is expected to update any underlying binding (WebGL framebuffer attachment) */\n  protected abstract updateAttachments(): void;\n\n  static override defaultProps: Required<FramebufferProps> = {\n    ...Resource.defaultProps,\n    width: 1,\n    height: 1,\n    colorAttachments: [], // ['rgba8unorm'],\n    depthStencilAttachment: null // 'depth24plus-stencil8'\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {UniformValue} from '../types/uniforms';\nimport type {PrimitiveTopology, RenderPipelineParameters} from '../types/parameters';\nimport type {ShaderLayout, Binding} from '../types/shader-layout';\nimport type {BufferLayout} from '../types/buffer-layout';\nimport type {\n  TextureFormatColor,\n  TextureFormatDepthStencil\n} from '@luma.gl/core/shadertypes/textures/texture-formats';\nimport type {Shader} from './shader';\nimport type {RenderPass} from './render-pass';\nimport {Resource, ResourceProps} from './resource';\nimport {VertexArray} from './vertex-array';\nimport {TransformFeedback} from './transform-feedback';\n\nexport type RenderPipelineProps = ResourceProps & {\n  // Shaders and shader layout\n\n  /** Compiled vertex shader */\n  vs?: Shader | null;\n  /** Name of vertex shader stage main function (defaults to 'main'). WGSL only */\n  vertexEntryPoint?: string; //\n  /** Constant values to apply to compiled vertex shader. Do not require re-compilation. (WGSL only) */\n  vsConstants?: Record<string, number>; // WGSL only\n  /** Compiled fragment shader */\n  fs?: Shader | null;\n  /** Name of fragment shader stage main function (defaults to 'main'). WGSL only */\n  fragmentEntryPoint?: string; // WGSL only\n  /** Constant values to apply to compiled fragment shader. Do not require re-compilation. (WGSL only) */\n  fsConstants?: Record<string, number>;\n\n  /** Describes the attributes and bindings exposed by the pipeline shader(s). */\n  shaderLayout?: ShaderLayout | null;\n  /** Describes the buffers accepted by this pipeline and how they are mapped to shader attributes. */\n  bufferLayout?: BufferLayout[]; // Record<string, Omit<BufferLayout, 'name'>\n\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology?: PrimitiveTopology;\n\n  // color attachment information (needed on WebGPU)\n\n  /** Color attachments expected by this pipeline. Defaults to [device.preferredColorFormat]. Array needs not be contiguous. */\n  colorAttachmentFormats?: (TextureFormatColor | null)[];\n  /** Depth attachment expected by this pipeline. Defaults to device.preferredDepthFormat, if depthWriteEnables parameter is set */\n  depthStencilAttachmentFormat?: TextureFormatDepthStencil;\n\n  /** Parameters that are controlled by pipeline */\n  parameters?: RenderPipelineParameters;\n\n  // Dynamic bindings (TODO - pipelines should be immutable, move to RenderPass)\n\n  /** Buffers, Textures, Samplers for the shader bindings */\n  bindings?: Record<string, Binding>;\n  /** @deprecated uniforms (WebGL only) */\n  uniforms?: Record<string, UniformValue>;\n};\n\n/**\n * A compiled and linked shader program\n */\nexport abstract class RenderPipeline extends Resource<RenderPipelineProps> {\n  override get [Symbol.toStringTag](): string {\n    return 'RenderPipeline';\n  }\n\n  abstract readonly vs: Shader;\n  abstract readonly fs: Shader | null;\n\n  /** The merged layout */\n  shaderLayout: ShaderLayout;\n  /** Buffer map describing buffer interleaving etc */\n  readonly bufferLayout: BufferLayout[];\n  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */\n  linkStatus: 'pending' | 'success' | 'error' = 'pending';\n  /** The hash of the pipeline */\n  hash: string = '';\n\n  constructor(device: Device, props: RenderPipelineProps) {\n    super(device, props, RenderPipeline.defaultProps);\n    this.shaderLayout = this.props.shaderLayout!;\n    this.bufferLayout = this.props.bufferLayout || [];\n  }\n\n  /** Set bindings (stored on pipeline and set before each call) */\n  abstract setBindings(\n    bindings: Record<string, Binding>,\n    options?: {disableWarnings?: boolean}\n  ): void;\n\n  /** Draw call. Returns false if the draw call was aborted (due to resources still initializing) */\n  abstract draw(options: {\n    /** Render pass to draw into (targeting screen or framebuffer) */\n    renderPass?: RenderPass;\n    /** Parameters to be set during draw call. Note that most parameters can only be overridden in WebGL. */\n    parameters?: RenderPipelineParameters;\n    /** Topology. Note can only be overridden in WebGL. */\n    topology?: PrimitiveTopology;\n    /** vertex attributes */\n    vertexArray: VertexArray;\n    /** Use instanced rendering? */\n    isInstanced?: boolean;\n    /** Number of \"rows\" in 'instance' buffers */\n    instanceCount?: number;\n    /** Number of \"rows\" in 'vertex' buffers */\n    vertexCount?: number;\n    /** Number of \"rows\" in index buffer */\n    indexCount?: number;\n    /** First vertex to draw from */\n    firstVertex?: number;\n    /** First index to draw from */\n    firstIndex?: number;\n    /** First instance to draw from */\n    firstInstance?: number;\n    baseVertex?: number;\n    /** Transform feedback. WebGL only. */\n    transformFeedback?: TransformFeedback;\n  }): boolean;\n\n  static override defaultProps: Required<RenderPipelineProps> = {\n    ...Resource.defaultProps,\n\n    vs: null,\n    vertexEntryPoint: 'vertexMain',\n    vsConstants: {},\n\n    fs: null,\n    fragmentEntryPoint: 'fragmentMain',\n    fsConstants: {},\n\n    shaderLayout: null,\n    bufferLayout: [],\n    topology: 'triangle-list',\n\n    colorAttachmentFormats: undefined!,\n    depthStencilAttachmentFormat: undefined!,\n\n    parameters: {},\n\n    bindings: {},\n    uniforms: {}\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray4, TypedArray} from '@math.gl/types';\nimport type {Device} from '../device';\nimport type {RenderPassParameters} from '../types/parameters';\n// import {Binding} from '../types/shader-layout';\nimport {Resource, ResourceProps} from './resource';\nimport {Framebuffer} from './framebuffer';\nimport {QuerySet} from './query-set';\n\n/**\n * Properties for a RenderPass instance is a required parameter to all draw calls.\n */\nexport type RenderPassProps = ResourceProps & {\n  /** Framebuffer specifies which textures to render into. Default gets framebuffer from canvas context. */\n  framebuffer?: Framebuffer | null;\n  /** Control viewport, scissor rect, blend constant and stencil ref */\n  parameters?: RenderPassParameters;\n\n  // TODO - API needs to be able to control multiple render targets\n\n  /** Clear value for color attachment, or false to preserve the previous value */\n  clearColor?: NumberArray4 | TypedArray | false;\n  /** Experimental: Clear color values for multiple color attachments. Must specify typed arrays. props.clearColor will be ignored. */\n  clearColors?: (TypedArray | false)[];\n  /** Clear value for depth attachment (true === `1`), or false to preserve the previous value. Must be between 0.0 (near) and 1.0 (far), inclusive. */\n  clearDepth?: number | false;\n  /** Clear value for stencil attachment (true === `0`), or false to preserve the previous value. Converted to the type and number of LSBs as the number of bits in the stencil aspect */\n  clearStencil?: number | false;\n\n  /** Indicates that the depth component is read only. */\n  depthReadOnly?: boolean;\n  /** Indicates that the stencil component is read only. */\n  stencilReadOnly?: boolean;\n\n  /** Whether to disable / discard the output of the rasterizer */\n  discard?: boolean;\n\n  /** QuerySet to write begin/end timestamps to */\n  occlusionQuerySet?: QuerySet;\n  /** QuerySet to write begin/end timestamps to */\n  timestampQuerySet?: QuerySet;\n  /** QuerySet index to write begin timestamp to. No timestamp is written if not provided. */\n  beginTimestampIndex?: number;\n  /** QuerySet index to write end timestamp to. No timestamp is written if not provided. */\n  endTimestampIndex?: number;\n};\n\n/**\n * A RenderPass instance is a required parameter to all draw calls.\n *\n * It holds a combination of\n * - render targets (specified via a framebuffer)\n * - clear colors, read/write, discard information for the framebuffer attachments\n * - a couple of mutable parameters ()\n */\nexport abstract class RenderPass extends Resource<RenderPassProps> {\n  /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */\n  static defaultClearColor: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth 1.0 represents the far plance */\n  static defaultClearDepth = 1;\n  /** Clears all stencil bits */\n  static defaultClearStencil = 0;\n\n  override get [Symbol.toStringTag](): string {\n    return 'RenderPass';\n  }\n\n  constructor(device: Device, props: RenderPassProps) {\n    props = RenderPass.normalizeProps(device, props);\n    super(device, props, RenderPass.defaultProps);\n  }\n\n  /** Call when rendering is done in this pass. */\n  abstract end(): void;\n\n  /** A few parameters can be changed at any time (viewport, scissorRect, blendColor, stencilReference) */\n  abstract setParameters(parameters: RenderPassParameters): void;\n\n  // executeBundles(bundles: Iterable<GPURenderBundle>): void;\n\n  /** Being an occlusion query. Value will be stored in the occlusionQuerySet at the index. Occlusion queries cannot be nested. */\n  abstract beginOcclusionQuery(queryIndex: number): void;\n  /** End an occlusion query. Stores result in the index specified in beginOcclusionQuery. */\n  abstract endOcclusionQuery(): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  protected static normalizeProps(device: Device, props: RenderPassProps): RenderPassProps {\n    return props;\n  }\n\n  /** Default properties for RenderPass */\n  static override defaultProps: Required<RenderPassProps> = {\n    ...Resource.defaultProps,\n    framebuffer: null,\n    parameters: undefined!,\n    clearColor: RenderPass.defaultClearColor,\n    clearColors: undefined!,\n    clearDepth: RenderPass.defaultClearDepth,\n    clearStencil: RenderPass.defaultClearStencil,\n    depthReadOnly: false,\n    stencilReadOnly: false,\n    discard: false,\n\n    occlusionQuerySet: undefined!,\n    timestampQuerySet: undefined!,\n    beginTimestampIndex: undefined!,\n    endTimestampIndex: undefined!\n  };\n}\n\n// TODO - Can we align WebGL implementation with WebGPU API?\n// In WebGPU the following methods are on the renderpass instead of the renderpipeline\n// luma.gl keeps them on the pipeline for now, but that has some issues.\n\n// abstract setPipeline(pipeline: RenderPipeline): void {}\n// abstract setIndexBuffer()\n// abstract setVertexBuffer(slot: number, buffer: Buffer, offset: number): void;\n// abstract setBindings(bindings: Record<string, Binding>): void;\n// abstract setParameters(parameters: RenderPassParameters);\n// abstract draw(options: {\n// abstract drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n// abstract drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): void;\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Resource, ResourceProps} from './resource';\nimport type {ComputeShaderLayout, Binding} from '../types/shader-layout';\nimport type {Device} from '../device';\nimport type {Shader} from './shader';\n\n/**\n * Properties for a compute pipeline\n */\nexport type ComputePipelineProps = ResourceProps & {\n  handle?: unknown;\n  /** Compiled shader object */\n  shader: Shader;\n  /** The entry point, defaults to main */\n  entryPoint?: string;\n  /** These are WGSL constant values - different from GLSL defines in that shader does not need to be recompiled */\n  constants?: Record<string, number>;\n  /** Describes the attributes and bindings exposed by the pipeline shader(s). */\n  shaderLayout?: ComputeShaderLayout | null;\n};\n\n/**\n * A compiled and linked shader program for compute\n */\nexport abstract class ComputePipeline extends Resource<ComputePipelineProps> {\n  override get [Symbol.toStringTag](): string {\n    return 'ComputePipeline';\n  }\n\n  hash: string = '';\n  /** The merged shader layout */\n  shaderLayout: ComputeShaderLayout;\n\n  constructor(device: Device, props: ComputePipelineProps) {\n    super(device, props, ComputePipeline.defaultProps);\n    this.shaderLayout = props.shaderLayout!;\n  }\n\n  /**\n   * @todo Use renderpass.setBindings() ?\n   * @todo Do we want to expose BindGroups in the API and remove this?\n   */\n  abstract setBindings(bindings: Record<string, Binding>): void;\n\n  static override defaultProps: Required<ComputePipelineProps> = {\n    ...Resource.defaultProps,\n    shader: undefined!,\n    entryPoint: undefined!,\n    constants: {},\n    shaderLayout: undefined!\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Resource, ResourceProps} from './resource';\nimport {ComputePipeline} from './compute-pipeline';\nimport type {Device} from '../device';\nimport {Buffer} from './buffer';\nimport {QuerySet} from './query-set';\n\nexport type ComputePassProps = ResourceProps & {\n  /** QuerySet to write beging/end timestamps to */\n  timestampQuerySet?: QuerySet;\n  /** QuerySet index to write begin timestamp to. No timestamp is written if not provided. */\n  beginTimestampIndex?: number;\n  /** QuerySet index to write end timestamp to. No timestamp is written if not provided. */\n  endTimestampIndex?: number;\n};\n\nexport abstract class ComputePass extends Resource<ComputePassProps> {\n  constructor(device: Device, props: ComputePassProps) {\n    super(device, props, ComputePass.defaultProps);\n  }\n\n  abstract override destroy(): void;\n\n  abstract end(): void;\n\n  abstract setPipeline(pipeline: ComputePipeline): void;\n\n  /** Sets an array of bindings (uniform buffers, samplers, textures, ...) */\n  // abstract setBindings(bindings: Binding[]): void;\n\n  /**\n   * Dispatch work to be performed with the current ComputePipeline.\n   * @param x X dimension of the grid of workgroups to dispatch.\n   * @param y Y dimension of the grid of workgroups to dispatch.\n   * @param z Z dimension of the grid of workgroups to dispatch.\n   */\n  abstract dispatch(x: number, y?: number, z?: number): void;\n\n  /**\n   * Dispatch work to be performed with the current ComputePipeline.\n   * @param indirectBuffer buffer must be a tightly packed block of three 32-bit unsigned integer values (12 bytes total), given in the same order as the arguments for dispatch()\n   * @param indirectOffset\n   */\n  abstract dispatchIndirect(indirectBuffer: Buffer, indirectOffset?: number): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  static override defaultProps: Required<ComputePassProps> = {\n    ...Resource.defaultProps,\n    timestampQuerySet: undefined!,\n    beginTimestampIndex: undefined!,\n    endTimestampIndex: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'ComputePass';\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// import type {TypedArray} from '@math.gl/types';\nimport {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\nimport {Buffer} from './buffer';\nimport {Texture} from './texture';\nimport {QuerySet} from './query-set';\nimport type {RenderPass, RenderPassProps} from './render-pass';\nimport type {ComputePass, ComputePassProps} from './compute-pass';\nimport type {CommandBuffer, CommandBufferProps} from './command-buffer';\n\n// WEBGPU COMMAND ENCODER OPERATIONS\n\nexport type CopyBufferToBufferOptions = {\n  sourceBuffer: Buffer;\n  sourceOffset?: number;\n  destinationBuffer: Buffer;\n  destinationOffset?: number;\n  size: number;\n};\n\nexport type CopyBufferToTextureOptions = {\n  sourceBuffer: Buffer;\n  byteOffset?: number;\n  destinationTexture: Texture;\n  mipLevel?: number; //  = 0;\n  origin?: [number, number, number] | number[];\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  bytesPerRow: number;\n  rowsPerImage: number;\n  size: [number, number, number] | number[];\n};\n\nexport type CopyTextureToBufferOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from.\n   * Together with `copySize`, defines the full copy sub-region.\n   */\n  /** Defines which aspects of the texture to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n  origin?: number[];\n\n  /** Destination buffer */\n  destinationBuffer: Buffer;\n  /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n  byteOffset?: number;\n  /**\n   * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n   * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n   */\n  bytesPerRow?: number;\n  /**\n   * Number of block rows per single image of the texture.\n   * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n   * Required if there are multiple images (i.e. the copy depth is more than one).\n   */\n  rowsPerImage?: number;\n};\n\nexport type CopyTextureToTextureOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */\n  origin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Texture to copy to/from. */\n  destinationTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  destinationMipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */\n  destinationOrigin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  destinationAspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n};\n\n// ADDITIONAL COMMAND ENCODER OPERATIONS DEFINED BY LUMA.GL\n\n/** Options for clearing a texture mip level */\nexport type ClearTextureOptions = {\n  /** Texture to Clear. */\n  texture: Texture;\n  /**  Mip-map level of the texture clear. (Default 0) */\n  mipLevel?: number;\n  /** Defines which aspects of the Texture to clear. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n};\n\n// export type WriteBufferOptions = {\n//   buffer: Buffer;\n//   bufferOffset?: number;\n//   data: BufferSource;\n//   dataOffset?: number;\n//   size?: number;\n// };\n\n// export type WriteTextureOptions = {\n//   destination: Texture;\n//   mipLevel?: number; //  = 0;\n//   origin?: [number, number, number] | number[];\n//   aspect?: 'all' | 'stencil-only' | 'depth-only';\n//   data: BufferSource;\n//   // dataLayout;\n//   offset: number;\n//   bytesPerRow: number;\n//   rowsPerImage: number;\n//   size: [number, number, number] | number[];\n// };\n\nexport type CommandEncoderProps = ResourceProps & {\n  measureExecutionTime?: boolean;\n};\n\n/**\n * Encodes commands to queue that can be executed later\n */\nexport abstract class CommandEncoder extends Resource<CommandEncoderProps> {\n  override get [Symbol.toStringTag](): string {\n    return 'CommandEncoder';\n  }\n\n  constructor(device: Device, props: CommandEncoderProps) {\n    super(device, props, CommandEncoder.defaultProps);\n  }\n\n  /** Completes recording of the commands sequence */\n  abstract finish(props?: CommandBufferProps): CommandBuffer;\n\n  /** Create a RenderPass using the default CommandEncoder */\n  abstract beginRenderPass(props?: RenderPassProps): RenderPass;\n\n  /** Create a ComputePass using the default CommandEncoder*/\n  abstract beginComputePass(props?: ComputePassProps): ComputePass;\n\n  /** Add a command that that copies data from a sub-region of a Buffer to a sub-region of another Buffer. */\n  abstract copyBufferToBuffer(options: CopyBufferToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of a GPUBuffer to a sub-region of one or multiple continuous texture subresources. */\n  abstract copyBufferToTexture(options: CopyBufferToTextureOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple continuous texture subresources to a sub-region of a Buffer. */\n  abstract copyTextureToBuffer(options: CopyTextureToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple contiguous texture subresources to another sub-region of one or multiple continuous texture subresources. */\n  abstract copyTextureToTexture(options: CopyTextureToTextureOptions): void;\n\n  /** Add a command that clears a texture mip level. */\n  // abstract clearTexture(options: ClearTextureOptions): void;\n\n  // abstract readTexture(options: ReadTextureOptions): Promise<TypedArray>;\n\n  /** Reads results from a query set into a GPU buffer. Values are 64 bits so byteLength must be querySet.props.count * 8 */\n  abstract resolveQuerySet(\n    querySet: QuerySet,\n    destination: Buffer,\n    options?: {\n      firstQuery?: number;\n      queryCount?: number;\n      destinationOffset?: number;\n    }\n  ): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  // TODO - luma.gl has these on the device, should we align with WebGPU API?\n  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;\n  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;\n\n  static override defaultProps: Required<CommandEncoderProps> = {\n    ...Resource.defaultProps,\n    measureExecutionTime: undefined!\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\n// interface Queue {\n//   submit(commandBuffers);\n\n//   // onSubmittedWorkDone(): Promise<undefined>;\n\n//   writeBuffer(options: WriteBufferOptions): void;\n//   writeTexture(options: WriteTextureOptions): void;\n\n//   // copyExternalImageToTexture(\n//   //   GPUImageCopyExternalImage source,\n//   //   GPUImageCopyTextureTagged destination,\n//   //   GPUExtent3D copySize\n//   // ): void;\n// }\n\nexport type CommandBufferProps = ResourceProps & {};\n\n/**\n * Encodes commands to queue that can be executed later\n */\nexport abstract class CommandBuffer extends Resource<CommandBufferProps> {\n  override get [Symbol.toStringTag](): string {\n    return 'CommandBuffer';\n  }\n\n  constructor(device: Device, props: CommandBufferProps) {\n    super(device, props, CommandBuffer.defaultProps);\n  }\n\n  static override defaultProps: Required<CommandBufferProps> = {\n    ...Resource.defaultProps\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PrimitiveDataType} from './data-types';\nimport type {\n  VariableShaderType,\n  AttributeShaderType,\n  AttributeShaderTypeInfo,\n  VariableShaderTypeAlias,\n  AttributeShaderTypeAlias\n} from './shader-types';\n\n/** Split a uniform type string into type and components */\nexport function getVariableShaderTypeInfo(format: VariableShaderType): {\n  type: PrimitiveDataType;\n  components: number;\n} {\n  const decoded = UNIFORM_FORMATS[format];\n  return decoded;\n}\n\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function getAttributeShaderTypeInfo(\n  attributeType: AttributeShaderType\n): AttributeShaderTypeInfo {\n  const [primitiveType, components] = TYPE_INFO[attributeType];\n  const integer: boolean = primitiveType === 'i32' || primitiveType === 'u32';\n  const signed: boolean = primitiveType !== 'u32';\n\n  const byteLength = PRIMITIVE_TYPE_SIZES[primitiveType] * components;\n  return {\n    primitiveType,\n    components,\n    byteLength,\n    integer,\n    signed\n  };\n}\n\nexport function makeShaderAttributeType(\n  primitiveType: PrimitiveDataType,\n  components: 1 | 2 | 3 | 4\n): AttributeShaderType {\n  return components === 1 ? primitiveType : `vec${components}<${primitiveType}>`;\n}\n\nexport function resolveAttributeShaderTypeAlias(\n  alias: AttributeShaderTypeAlias | AttributeShaderType\n): AttributeShaderType {\n  return WGSL_ATTRIBUTE_TYPE_ALIAS_MAP[alias as AttributeShaderTypeAlias] || alias;\n}\n\nexport function resolveVariableShaderTypeAlias(\n  alias: VariableShaderTypeAlias | VariableShaderType\n): VariableShaderType {\n  return WGSL_VARIABLE_TYPE_ALIAS_MAP[alias as VariableShaderTypeAlias] || alias;\n}\n\n// TABLES\n\nconst PRIMITIVE_TYPE_SIZES: Record<PrimitiveDataType, 2 | 4> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4\n  // 'bool-webgl': 4,\n};\n\n/** All valid shader attribute types. A table guarantees exhaustive list and fast execution */\nconst TYPE_INFO: Record<AttributeShaderType, [PrimitiveDataType, components: 1 | 2 | 3 | 4]> = {\n  f32: ['f32', 1],\n  'vec2<f32>': ['f32', 2],\n  'vec3<f32>': ['f32', 3],\n  'vec4<f32>': ['f32', 4],\n  f16: ['f16', 1],\n  'vec2<f16>': ['f16', 2],\n  'vec3<f16>': ['f16', 3],\n  'vec4<f16>': ['f16', 4],\n  i32: ['i32', 1],\n  'vec2<i32>': ['i32', 2],\n  'vec3<i32>': ['i32', 3],\n  'vec4<i32>': ['i32', 4],\n  u32: ['u32', 1],\n  'vec2<u32>': ['u32', 2],\n  'vec3<u32>': ['u32', 3],\n  'vec4<u32>': ['u32', 4]\n};\n\n/** @todo These tables are quite big, consider parsing type strings instead */\nconst UNIFORM_FORMATS: Record<VariableShaderType, {type: PrimitiveDataType; components: number}> = {\n  f32: {type: 'f32', components: 1},\n  f16: {type: 'f16', components: 1},\n  i32: {type: 'i32', components: 1},\n  u32: {type: 'u32', components: 1},\n  // 'bool-webgl': {type: 'bool-webgl', components: 1},\n  'vec2<f32>': {type: 'f32', components: 2},\n  'vec3<f32>': {type: 'f32', components: 3},\n  'vec4<f32>': {type: 'f32', components: 4},\n  'vec2<f16>': {type: 'f16', components: 2},\n  'vec3<f16>': {type: 'f16', components: 3},\n  'vec4<f16>': {type: 'f16', components: 4},\n  'vec2<i32>': {type: 'i32', components: 2},\n  'vec3<i32>': {type: 'i32', components: 3},\n  'vec4<i32>': {type: 'i32', components: 4},\n  'vec2<u32>': {type: 'u32', components: 2},\n  'vec3<u32>': {type: 'u32', components: 3},\n  'vec4<u32>': {type: 'u32', components: 4},\n\n  'mat2x2<f32>': {type: 'f32', components: 4},\n  'mat2x3<f32>': {type: 'f32', components: 6},\n  'mat2x4<f32>': {type: 'f32', components: 8},\n  'mat3x2<f32>': {type: 'f32', components: 6},\n  'mat3x3<f32>': {type: 'f32', components: 9},\n  'mat3x4<f32>': {type: 'f32', components: 12},\n  'mat4x2<f32>': {type: 'f32', components: 8},\n  'mat4x3<f32>': {type: 'f32', components: 12},\n  'mat4x4<f32>': {type: 'f32', components: 16},\n\n  'mat2x2<f16>': {type: 'f16', components: 4},\n  'mat2x3<f16>': {type: 'f16', components: 6},\n  'mat2x4<f16>': {type: 'f16', components: 8},\n  'mat3x2<f16>': {type: 'f16', components: 6},\n  'mat3x3<f16>': {type: 'f16', components: 9},\n  'mat3x4<f16>': {type: 'f16', components: 12},\n  'mat4x2<f16>': {type: 'f16', components: 8},\n  'mat4x3<f16>': {type: 'f16', components: 12},\n  'mat4x4<f16>': {type: 'f16', components: 16},\n\n  'mat2x2<i32>': {type: 'i32', components: 4},\n  'mat2x3<i32>': {type: 'i32', components: 6},\n  'mat2x4<i32>': {type: 'i32', components: 8},\n  'mat3x2<i32>': {type: 'i32', components: 6},\n  'mat3x3<i32>': {type: 'i32', components: 9},\n  'mat3x4<i32>': {type: 'i32', components: 12},\n  'mat4x2<i32>': {type: 'i32', components: 8},\n  'mat4x3<i32>': {type: 'i32', components: 12},\n  'mat4x4<i32>': {type: 'i32', components: 16},\n\n  'mat2x2<u32>': {type: 'u32', components: 4},\n  'mat2x3<u32>': {type: 'u32', components: 6},\n  'mat2x4<u32>': {type: 'u32', components: 8},\n  'mat3x2<u32>': {type: 'u32', components: 6},\n  'mat3x3<u32>': {type: 'u32', components: 9},\n  'mat3x4<u32>': {type: 'u32', components: 12},\n  'mat4x2<u32>': {type: 'u32', components: 8},\n  'mat4x3<u32>': {type: 'u32', components: 12},\n  'mat4x4<u32>': {type: 'u32', components: 16}\n};\n\n/**  Predeclared aliases @see https://www.w3.org/TR/WGSL/#vector-types */\nexport const WGSL_ATTRIBUTE_TYPE_ALIAS_MAP: Record<AttributeShaderTypeAlias, AttributeShaderType> =\n  {\n    vec2i: 'vec2<i32>',\n    vec3i: 'vec3<i32>',\n    vec4i: 'vec4<i32>',\n    vec2u: 'vec2<u32>',\n    vec3u: 'vec3<u32>',\n    vec4u: 'vec4<u32>',\n    vec2f: 'vec2<f32>',\n    vec3f: 'vec3<f32>',\n    vec4f: 'vec4<f32>',\n    // Requires the f16 extension.\n    vec2h: 'vec2<f16>',\n    vec3h: 'vec3<f16>',\n    vec4h: 'vec4<f16>'\n  };\n\n/** @todo These tables are quite big, consider parsing alias strings instead */\nexport const WGSL_VARIABLE_TYPE_ALIAS_MAP: Record<VariableShaderTypeAlias, VariableShaderType> = {\n  ...WGSL_ATTRIBUTE_TYPE_ALIAS_MAP,\n  mat2x2f: 'mat2x2<f32>',\n  mat2x3f: 'mat2x3<f32>',\n  mat2x4f: 'mat2x4<f32>',\n  mat3x2f: 'mat3x2<f32>',\n  mat3x3f: 'mat3x3<f32>',\n  mat3x4f: 'mat3x4<f32>',\n  mat4x2f: 'mat4x2<f32>',\n  mat4x3f: 'mat4x3<f32>',\n  mat4x4f: 'mat4x4<f32>',\n\n  mat2x2i: 'mat2x2<i32>',\n  mat2x3i: 'mat2x3<i32>',\n  mat2x4i: 'mat2x4<i32>',\n  mat3x2i: 'mat3x2<i32>',\n  mat3x3i: 'mat3x3<i32>',\n  mat3x4i: 'mat3x4<i32>',\n  mat4x2i: 'mat4x2<i32>',\n  mat4x3i: 'mat4x3<i32>',\n  mat4x4i: 'mat4x4<i32>',\n\n  mat2x2u: 'mat2x2<u32>',\n  mat2x3u: 'mat2x3<u32>',\n  mat2x4u: 'mat2x4<u32>',\n  mat3x2u: 'mat3x2<u32>',\n  mat3x3u: 'mat3x3<u32>',\n  mat3x4u: 'mat3x4<u32>',\n  mat4x2u: 'mat4x2<u32>',\n  mat4x3u: 'mat4x3<u32>',\n  mat4x4u: 'mat4x4<u32>',\n\n  mat2x2h: 'mat2x2<f16>',\n  mat2x3h: 'mat2x3<f16>',\n  mat2x4h: 'mat2x4<f16>',\n  mat3x2h: 'mat3x2<f16>',\n  mat3x3h: 'mat3x3<f16>',\n  mat3x4h: 'mat3x4<f16>',\n  mat4x2h: 'mat4x2<f16>',\n  mat4x3h: 'mat4x3<f16>',\n  mat4x4h: 'mat4x4<f16>'\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '../utils/log';\nimport type {PrimitiveDataType, NormalizedDataType} from '../shadertypes/data-types/data-types';\nimport type {AttributeShaderType} from '../shadertypes/data-types/shader-types';\nimport type {VertexFormat} from '../shadertypes/vertex-arrays/vertex-formats';\nimport {getAttributeShaderTypeInfo} from '../shadertypes/data-types/decode-shader-types';\nimport {\n  getVertexFormatInfo,\n  getCompatibleVertexFormat\n} from '../shadertypes/vertex-arrays/decode-vertex-format';\nimport type {ShaderLayout, AttributeDeclaration} from '../adapter/types/shader-layout';\nimport type {BufferLayout} from '../adapter/types/buffer-layout';\n\n/** Resolved info for a buffer / attribute combination to help backend configure it correctly */\nexport type AttributeInfo = {\n  /** Attribute name */\n  attributeName: string;\n  /** Location in shader */\n  location: number;\n  /** Type / precision used in shader (buffer values may be converted) */\n  shaderType: AttributeShaderType;\n  /** Calculations are done in this type in the shader's attribute declaration */\n  primitiveType: PrimitiveDataType;\n  /** Components refer to the number of components in the shader's attribute declaration */\n  shaderComponents: 1 | 2 | 3 | 4;\n  /** It is the shader attribute declaration that determines whether GPU will process as integer or float */\n  integer: boolean;\n\n  /** BufferName */\n  bufferName: string;\n  /** Format of buffer data */\n  vertexFormat: VertexFormat;\n  /** Memory data type refers to the data type in the buffer */\n  bufferDataType: NormalizedDataType;\n  /** Components refer to the number of components in the buffer's vertex format */\n  bufferComponents: 1 | 2 | 3 | 4;\n  /** Normalization is encoded in the buffer layout's vertex format... */\n  normalized: boolean;\n\n  /** If not specified, the step mode is inferred from the attribute name in the shader (contains string instance) */\n  stepMode: 'vertex' | 'instance';\n\n  /** The byteOffset is encoded in or calculated from the buffer layout */\n  byteOffset: number;\n  /** The byteStride is encoded in or calculated from the buffer layout */\n  byteStride: number;\n};\n\ntype BufferAttributeInfo = {\n  attributeName: string;\n  bufferName: string;\n  stepMode?: 'vertex' | 'instance';\n  vertexFormat: VertexFormat;\n  byteOffset: number;\n  byteStride: number;\n};\n\n/**\n * Map from \"attribute names\" to \"resolved attribute infos\"\n * containing information about both buffer layouts and shader attribute declarations\n */\nexport function getAttributeInfosFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[]\n): Record<string, AttributeInfo> {\n  const attributeInfos: Record<string, AttributeInfo> = {};\n  for (const attribute of shaderLayout.attributes) {\n    const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);\n    if (attributeInfo) {\n      attributeInfos[attribute.name] = attributeInfo;\n    }\n  }\n  return attributeInfos;\n}\n\n/**\n * Array indexed by \"location\" holding \"resolved attribute infos\"\n */\nexport function getAttributeInfosByLocation(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  maxVertexAttributes: number = 16\n): AttributeInfo[] {\n  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);\n  const locationInfos: AttributeInfo[] = new Array(maxVertexAttributes).fill(null);\n  for (const attributeInfo of Object.values(attributeInfos)) {\n    locationInfos[attributeInfo.location] = attributeInfo;\n  }\n  return locationInfos;\n}\n\n/**\n * Get the combined information from a shader layout and a buffer layout for a specific attribute\n */\nfunction getAttributeInfoFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  name: string\n): AttributeInfo | null {\n  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name);\n  const bufferMapping: BufferAttributeInfo | null = getAttributeFromBufferLayout(\n    bufferLayout,\n    name\n  );\n\n  // TODO should no longer happen\n  if (!shaderDeclaration) {\n    //  || !bufferMapping\n    return null;\n  }\n\n  const attributeTypeInfo = getAttributeShaderTypeInfo(shaderDeclaration.type);\n  const defaultVertexFormat = getCompatibleVertexFormat(attributeTypeInfo);\n  const vertexFormat = bufferMapping?.vertexFormat || defaultVertexFormat;\n  const vertexFormatInfo = getVertexFormatInfo(vertexFormat);\n\n  return {\n    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,\n    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,\n    location: shaderDeclaration.location,\n    shaderType: shaderDeclaration.type,\n    primitiveType: attributeTypeInfo.primitiveType,\n    shaderComponents: attributeTypeInfo.components,\n    vertexFormat,\n    bufferDataType: vertexFormatInfo.type,\n    bufferComponents: vertexFormatInfo.components,\n    // normalized is a property of the buffer's vertex format\n    normalized: vertexFormatInfo.normalized,\n    // integer is a property of the shader declaration\n    integer: attributeTypeInfo.integer,\n    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || 'vertex',\n    byteOffset: bufferMapping?.byteOffset || 0,\n    byteStride: bufferMapping?.byteStride || 0\n  };\n}\n\nfunction getAttributeFromShaderLayout(\n  shaderLayout: ShaderLayout,\n  name: string\n): AttributeDeclaration | null {\n  const attribute = shaderLayout.attributes.find(attr => attr.name === name);\n  if (!attribute) {\n    log.warn(`shader layout attribute \"${name}\" not present in shader`);\n  }\n  return attribute || null;\n}\n\nfunction getAttributeFromBufferLayout(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  // Check that bufferLayouts are valid (each either has format or attribute)\n  checkBufferLayouts(bufferLayouts);\n\n  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  // Didn't find...\n  log.warn(`layout for attribute \"${name}\" not present in buffer layout`);\n  return null;\n}\n\n/** Check that bufferLayouts are valid (each either has format or attribute) */\nfunction checkBufferLayouts(bufferLayouts: BufferLayout[]) {\n  for (const bufferLayout of bufferLayouts) {\n    if (\n      (bufferLayout.attributes && bufferLayout.format) ||\n      (!bufferLayout.attributes && !bufferLayout.format)\n    ) {\n      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);\n    }\n  }\n}\n\n/** Get attribute from format shorthand if specified */\nfunction getAttributeFromShortHand(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    if (bufferLayout.format && bufferLayout.name === name) {\n      return {\n        attributeName: bufferLayout.name,\n        bufferName: name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: bufferLayout.format,\n        // If offset is needed, use `attributes` field.\n        byteOffset: 0,\n        byteStride: bufferLayout.byteStride || 0\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * Search attribute mappings (e.g. interleaved attributes) for buffer mapping.\n * Not the name of the buffer might be the same as one of the interleaved attributes.\n */\nfunction getAttributeFromAttributesList(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    let byteStride: number | undefined = bufferLayout.byteStride;\n\n    // Calculate a default byte stride if not provided\n    if (typeof bufferLayout.byteStride !== 'number') {\n      for (const attributeMapping of bufferLayout.attributes || []) {\n        const info = getVertexFormatInfo(attributeMapping.format);\n        // @ts-ignore\n        byteStride += info.byteLength;\n      }\n    }\n\n    const attributeMapping = bufferLayout.attributes?.find(mapping => mapping.attribute === name);\n    if (attributeMapping) {\n      return {\n        attributeName: attributeMapping.attribute,\n        bufferName: bufferLayout.name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: attributeMapping.format,\n        byteOffset: attributeMapping.byteOffset,\n        // @ts-ignore\n        byteStride\n      };\n    }\n  }\n\n  return null;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '../../types';\nimport {\n  AttributeInfo,\n  getAttributeInfosByLocation\n} from '../../adapter-utils/get-attribute-from-layouts';\nimport type {Device} from '../device';\nimport type {Buffer} from './buffer';\nimport type {RenderPass} from './render-pass';\nimport {Resource, ResourceProps} from './resource';\nimport {ShaderLayout} from '../types/shader-layout';\nimport {BufferLayout} from '../types/buffer-layout';\n\n/** Properties for initializing a VertexArray */\nexport type VertexArrayProps = ResourceProps & {\n  shaderLayout: ShaderLayout;\n  bufferLayout: BufferLayout[];\n};\n\n/**\n * Stores attribute bindings.\n * Makes it easy to share a render pipeline and use separate vertex arrays.\n * @note On WebGL, VertexArray allows non-constant bindings to be performed in advance\n * reducing the number of WebGL calls per draw call.\n * @note On WebGPU this is just a convenience class that collects the bindings.\n */\nexport abstract class VertexArray extends Resource<VertexArrayProps> {\n  static override defaultProps: Required<VertexArrayProps> = {\n    ...Resource.defaultProps,\n    shaderLayout: undefined!,\n    bufferLayout: []\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'VertexArray';\n  }\n\n  /** Max number of vertex attributes */\n  readonly maxVertexAttributes: number;\n  /** Attribute infos indexed by location - TODO only needed by webgl module? */\n  protected readonly attributeInfos: AttributeInfo[];\n\n  /** Index buffer */\n  indexBuffer: Buffer | null = null;\n  /** Attributes indexed by buffer slot */\n  attributes: (Buffer | TypedArray | null)[];\n\n  constructor(device: Device, props: VertexArrayProps) {\n    super(device, props, VertexArray.defaultProps);\n    this.maxVertexAttributes = device.limits.maxVertexAttributes;\n    this.attributes = new Array(this.maxVertexAttributes).fill(null);\n    this.attributeInfos = getAttributeInfosByLocation(\n      props.shaderLayout,\n      props.bufferLayout,\n      this.maxVertexAttributes\n    );\n  }\n\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setIndexBuffer(indices: Buffer | null): void;\n  /** Set attributes (stored on pipeline and set before each call) */\n  abstract setBuffer(bufferSlot: number, buffer: Buffer | null): void;\n\n  abstract bindBeforeRender(renderPass: RenderPass): void;\n  abstract unbindAfterRender(renderPass: RenderPass): void;\n\n  // DEPRECATED METHODS\n\n  /** @deprecated Set constant attributes (WebGL only) */\n  setConstantWebGL(location: number, value: TypedArray | null): void {\n    this.device.reportError(new Error('constant attributes not supported'), this)();\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {PrimitiveTopology} from '../types/parameters';\nimport {ShaderLayout} from '../types/shader-layout';\nimport type {Buffer} from './buffer';\nimport {Resource, ResourceProps} from './resource';\n\n/** For bindRange */\nexport type BufferRange = {\n  buffer: Buffer;\n  byteOffset?: number;\n  byteLength?: number;\n};\n\n/** Configures a set of output buffers for pipeline (WebGL only) */\nexport type TransformFeedbackProps = ResourceProps & {\n  /** Layout of shader (for varyings) */\n  layout: ShaderLayout;\n  /** Buffer bindings (for varyings) */\n  buffers: Record<string, Buffer | BufferRange>;\n};\n\n/** Holds a set of output buffers for pipeline (WebGL only) */\nexport abstract class TransformFeedback extends Resource<TransformFeedbackProps> {\n  static override defaultProps: Required<TransformFeedbackProps> = {\n    ...Resource.defaultProps,\n    layout: undefined!,\n    buffers: {}\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'TransformFeedback';\n  }\n\n  constructor(device: Device, props: TransformFeedbackProps) {\n    super(device, props, TransformFeedback.defaultProps);\n  }\n\n  abstract begin(topology?: PrimitiveTopology): void;\n  abstract end(): void;\n\n  abstract setBuffers(buffers: Record<string, Buffer | BufferRange>): void;\n  abstract setBuffer(locationOrName: string | number, bufferOrRange: Buffer | BufferRange): void;\n  abstract getBuffer(locationOrName: string | number): Buffer | BufferRange | null;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\n/**\n * Properties for creating a QuerySet\n * - 'timestamp' - query the GPU timestamp counter at the start and end of render passes\n *   timestamp queries are available if the 'timestamp-query' feature is present.\n * - 'occlusion' - query the number of fragment samples that pass all per-fragment tests for a set of drawing commands\n *   including scissor, sample mask, alpha to coverage, stencil, and depth tests\n */\nexport type QuerySetProps = ResourceProps & {\n  /**\n   * The type of query set\n   * occlusion - query the number of fragment samples that pass all the per-fragment tests for a set of drawing commands, including scissor, sample mask, alpha to coverage, stencil, and depth tests\n   * timestamp - query the GPU timestamp counter at the start and end of render passes\n   */\n  type: 'occlusion' | 'timestamp';\n  /** The number of queries managed by the query set */\n  count: number;\n};\n\n/** Immutable QuerySet object */\nexport abstract class QuerySet extends Resource<QuerySetProps> {\n  get [Symbol.toStringTag](): string {\n    return 'QuerySet';\n  }\n\n  constructor(device: Device, props: QuerySetProps) {\n    super(device, props, QuerySet.defaultProps);\n  }\n\n  static override defaultProps: Required<QuerySetProps> = {\n    ...Resource.defaultProps,\n    type: undefined!,\n    count: undefined!\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '../device';\nimport {ShaderLayout} from '../types/shader-layout';\nimport {Resource, ResourceProps} from './resource';\n\nexport type PipelineLayoutProps = ResourceProps & {\n  shaderLayout: ShaderLayout;\n};\n\n/** Immutable PipelineLayout object */\nexport abstract class PipelineLayout extends Resource<PipelineLayoutProps> {\n  get [Symbol.toStringTag](): string {\n    return 'PipelineLayout';\n  }\n\n  constructor(device: Device, props: PipelineLayoutProps) {\n    super(device, props, PipelineLayout.defaultProps);\n  }\n\n  static override defaultProps: Required<PipelineLayoutProps> = {\n    ...Resource.defaultProps,\n    shaderLayout: {\n      attributes: [],\n      bindings: []\n    }\n  };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '../types';\n\nlet arrayBuffer: ArrayBuffer;\n\nexport function getScratchArrayBuffer(byteLength: number): ArrayBuffer {\n  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {\n    arrayBuffer = new ArrayBuffer(byteLength);\n  }\n  return arrayBuffer;\n}\n\nexport function getScratchArray(Type: any, length: number): TypedArray {\n  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);\n  return new Type(scratchArrayBuffer, 0, length); // arrayBuffer, byteOffset, length (in elements)\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray, NumberArray} from '../types';\n\n/**\n * Check is an array is a typed array\n * @param value value to be tested\n * @returns input as TypedArray, or null\n * @todo this should be provided by @math.gl/types\n */\nexport function isTypedArray(value: unknown): value is TypedArray {\n  return ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\n\n/**\n * Check is an array is a numeric array (typed array or array of numbers)\n * @param value value to be tested\n * @returns input as NumberArray, or null\n * @todo this should be provided by @math.gl/types\n */\nexport function isNumberArray(value: unknown): value is NumberArray {\n  if (Array.isArray(value)) {\n    return value.length === 0 || typeof value[0] === 'number';\n  }\n  return isTypedArray(value);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {PrimitiveDataType} from '../shadertypes/data-types/data-types';\nimport type {VariableShaderType} from '../shadertypes/data-types/shader-types';\nimport {alignTo} from '../shadertypes/data-types/decode-data-types';\nimport {getVariableShaderTypeInfo} from '../shadertypes/data-types/decode-shader-types';\n\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {getScratchArrayBuffer} from '../utils/array-utils-flat';\nimport {isNumberArray} from '../utils/is-array';\nimport {log} from '../utils/log';\n\n/**\n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize: number = 1024;\n\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n  readonly layout: Record<string, {offset: number; size: number; type: PrimitiveDataType}> = {};\n\n  /** number of bytes needed for buffer allocation */\n  readonly byteLength: number;\n\n  /** Create a new UniformBufferLayout given a map of attributes. */\n  constructor(\n    uniformTypes: Record<string, VariableShaderType>,\n    uniformSizes: Record<string, number> = {}\n  ) {\n    /** number of 4 byte slots taken */\n    let size: number = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const [key, uniformType] of Object.entries(uniformTypes)) {\n      const typeAndComponents = getVariableShaderTypeInfo(uniformType);\n      const {type, components} = typeAndComponents;\n      // Calculate total count for uniform arrays.\n      const count = components * (uniformSizes?.[key] ?? 1);\n      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n      size = alignTo(size, count);\n      // Use the aligned size as the offset of the current uniform.\n      const offset = size;\n      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n      size += count;\n      this.layout[key] = {type, size: count, offset};\n    }\n    size += (4 - (size % 4)) % 4;\n\n    const actualByteLength = size * 4;\n    this.byteLength = Math.max(actualByteLength, minBufferSize);\n  }\n\n  /** Get the data for the complete buffer */\n  getData(uniformValues: Record<string, UniformValue>): Uint8Array {\n    // Allocate three typed arrays pointing at same memory\n    const arrayBuffer = getScratchArrayBuffer(this.byteLength);\n    const typedArrays = {\n      i32: new Int32Array(arrayBuffer),\n      u32: new Uint32Array(arrayBuffer),\n      f32: new Float32Array(arrayBuffer),\n      // TODO not implemented\n      f16: new Uint16Array(arrayBuffer)\n    };\n\n    for (const [name, value] of Object.entries(uniformValues)) {\n      const uniformLayout = this.layout[name];\n      if (!uniformLayout) {\n        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const {type, size, offset} = uniformLayout;\n      const typedArray = typedArrays[type];\n      if (size === 1) {\n        if (typeof value !== 'number' && typeof value !== 'boolean') {\n          log.warn(\n            `Supplied value for single component uniform ${name} is not a number: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // single value -> just set it\n        typedArray[offset] = Number(value);\n      } else {\n        if (!isNumberArray(value)) {\n          log.warn(\n            `Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        // TODO: we should limit or check size in case the supplied data overflows\n        typedArray.set(value, offset);\n      }\n    }\n\n    return new Uint8Array(arrayBuffer, 0, this.byteLength);\n  }\n\n  /** Does this layout have a field with specified name */\n  has(name: string) {\n    return Boolean(this.layout[name]);\n  }\n\n  /** Get offset and size for a field with specified name */\n  get(name: string): {offset: number; size: number} | undefined {\n    const layout = this.layout[name];\n    return layout;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isNumberArray} from './is-array';\n\n/** Test if two arrays are deep equal, with a length limit that defaults to 16 */\nexport function arrayEqual(a: unknown, b: unknown, limit: number = 16) {\n  if (a !== b) {\n    return false;\n  }\n  const arrayA = a;\n  const arrayB = b;\n  if (!isNumberArray(arrayA)) {\n    return false;\n  }\n  if (isNumberArray(arrayB) && arrayA.length === arrayB.length) {\n    for (let i = 0; i < arrayA.length; ++i) {\n      if (arrayB[i] !== arrayA[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/** Copy a value */\nexport function arrayCopy<T>(a: T): T {\n  if (isNumberArray(a)) {\n    return a.slice() as T;\n  }\n  return a;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {VariableShaderType} from '../shadertypes/data-types/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {\n  ShaderLayout,\n  UniformInfo,\n  UniformBufferBindingLayout\n} from '../adapter/types/shader-layout';\nimport {arrayEqual, arrayCopy} from '../utils/array-equal';\n\n/**\n * A uniform block holds values of the of uniform values for one uniform block / buffer.\n * It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformBlock<\n  TUniforms extends Record<string, UniformValue> = Record<string, UniformValue>\n> {\n  name: string;\n\n  uniforms: Record<keyof TUniforms, UniformValue> = {} as Record<keyof TUniforms, UniformValue>;\n  modifiedUniforms: Record<keyof TUniforms, boolean> = {} as Record<keyof TUniforms, boolean>;\n  modified: boolean = true;\n\n  readonly bindingLayout: Record<string, UniformInfo> = {};\n  needsRedraw: string | false = 'initialized';\n\n  constructor(props?: {\n    name?: string;\n    shaderLayout?: ShaderLayout;\n    uniformTypes?: Record<keyof TUniforms, Record<string, VariableShaderType>>;\n  }) {\n    this.name = props?.name || 'unnamed';\n\n    // TODO - Extract uniform layout from the shaderLayout object\n    if (props?.name && props?.shaderLayout) {\n      const binding = props?.shaderLayout.bindings?.find(\n        binding_ => binding_.type === 'uniform' && binding_.name === props?.name\n      );\n      if (!binding) {\n        throw new Error(props?.name);\n      }\n\n      const uniformBlock = binding as UniformBufferBindingLayout;\n      for (const uniform of uniformBlock.uniforms || []) {\n        this.bindingLayout[uniform.name] = uniform;\n      }\n    }\n  }\n\n  /** Set a map of uniforms */\n  setUniforms(uniforms: Partial<TUniforms>): void {\n    for (const [key, value] of Object.entries(uniforms)) {\n      this._setUniform(key, value);\n      if (!this.needsRedraw) {\n        this.setNeedsRedraw(`${this.name}.${key}=${value}`);\n      }\n    }\n  }\n\n  setNeedsRedraw(reason: string): void {\n    this.needsRedraw = this.needsRedraw || reason;\n  }\n\n  /** Returns all uniforms */\n  getAllUniforms(): Record<string, UniformValue> {\n    // @ts-expect-error\n    this.modifiedUniforms = {};\n    this.needsRedraw = false;\n    return (this.uniforms || {}) as Record<string, UniformValue>;\n  }\n\n  /** Set a single uniform */\n  private _setUniform(key: keyof TUniforms, value: UniformValue) {\n    if (arrayEqual(this.uniforms[key], value)) {\n      return;\n    }\n    this.uniforms[key] = arrayCopy(value);\n    this.modifiedUniforms[key] = true;\n    this.modified = true;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {VariableShaderType} from '../shadertypes/data-types/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport type {Device} from '../adapter/device';\nimport {Buffer} from '../adapter/resources/buffer';\nimport {log} from '../utils/log';\nimport {UniformBlock} from './uniform-block';\nimport {UniformBufferLayout} from './uniform-buffer-layout';\n\n/**\n * A uniform store holds a uniform values for one or more uniform blocks,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformStore<\n  TPropGroups extends Record<string, Record<string, unknown>> = Record<\n    string,\n    Record<string, unknown>\n  >\n> {\n  /** Stores the uniform values for each uniform block */\n  uniformBlocks = new Map<keyof TPropGroups, UniformBlock>();\n  /** Can generate data for a uniform buffer for each block from data */\n  uniformBufferLayouts = new Map<keyof TPropGroups, UniformBufferLayout>();\n  /** Actual buffer for the blocks */\n  uniformBuffers = new Map<keyof TPropGroups, Buffer>();\n\n  /**\n   * Create a new UniformStore instance\n   * @param blocks\n   */\n  constructor(\n    blocks: Record<\n      keyof TPropGroups,\n      {\n        uniformTypes?: Record<string, VariableShaderType>;\n        uniformSizes?: Record<string, number>;\n        defaultProps?: Record<string, unknown>;\n        defaultUniforms?: Record<string, UniformValue>;\n      }\n    >\n  ) {\n    for (const [bufferName, block] of Object.entries(blocks)) {\n      const uniformBufferName = bufferName as keyof TPropGroups;\n\n      // Create a layout object to help us generate correctly formatted binary uniform buffers\n      const uniformBufferLayout = new UniformBufferLayout(\n        block.uniformTypes ?? {},\n        block.uniformSizes ?? {}\n      );\n      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);\n\n      // Create a Uniform block to store the uniforms for each buffer.\n      const uniformBlock = new UniformBlock({name: bufferName});\n      uniformBlock.setUniforms(block.defaultUniforms || {});\n      this.uniformBlocks.set(uniformBufferName, uniformBlock);\n    }\n  }\n\n  /** Destroy any managed uniform buffers */\n  destroy(): void {\n    for (const uniformBuffer of this.uniformBuffers.values()) {\n      uniformBuffer.destroy();\n    }\n  }\n\n  /**\n   * Set uniforms\n   * Makes all properties partial\n   */\n  setUniforms(\n    uniforms: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): void {\n    for (const [blockName, uniformValues] of Object.entries(uniforms)) {\n      this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);\n      // We leverage logging in updateUniformBuffers(), even though slightly less efficient\n      // this.updateUniformBuffer(blockName);\n    }\n\n    this.updateUniformBuffers();\n  }\n\n  /** Get the required minimum length of the uniform buffer */\n  getUniformBufferByteLength(uniformBufferName: keyof TPropGroups): number {\n    return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;\n  }\n\n  /** Get formatted binary memory that can be uploaded to a buffer */\n  getUniformBufferData(uniformBufferName: keyof TPropGroups): Uint8Array {\n    const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};\n    // @ts-ignore\n    return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);\n  }\n\n  /**\n   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)\n   * The new buffer is initialized with current / supplied values\n   */\n  createUniformBuffer(\n    device: Device,\n    uniformBufferName: keyof TPropGroups,\n    uniforms?: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): Buffer {\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n    const uniformBuffer = device.createBuffer({\n      usage: Buffer.UNIFORM | Buffer.COPY_DST,\n      byteLength\n    });\n    // Note that this clears the needs redraw flag\n    const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n    uniformBuffer.write(uniformBufferData);\n    return uniformBuffer;\n  }\n\n  /** Get the managed uniform buffer. \"managed\" resources are destroyed when the uniformStore is destroyed. */\n  getManagedUniformBuffer(device: Device, uniformBufferName: keyof TPropGroups): Buffer {\n    if (!this.uniformBuffers.get(uniformBufferName)) {\n      const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n      const uniformBuffer = device.createBuffer({\n        usage: Buffer.UNIFORM | Buffer.COPY_DST,\n        byteLength\n      });\n      this.uniformBuffers.set(uniformBufferName, uniformBuffer);\n    }\n    // this.updateUniformBuffers();\n    // @ts-ignore\n    return this.uniformBuffers.get(uniformBufferName);\n  }\n\n  /** Updates all uniform buffers where values have changed */\n  updateUniformBuffers(): false | string {\n    let reason: false | string = false;\n    for (const uniformBufferName of this.uniformBlocks.keys()) {\n      const bufferReason = this.updateUniformBuffer(uniformBufferName);\n      reason ||= bufferReason;\n    }\n    if (reason) {\n      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();\n    }\n    return reason;\n  }\n\n  /** Update one uniform buffer. Only updates if values have changed */\n  updateUniformBuffer(uniformBufferName: keyof TPropGroups): false | string {\n    const uniformBlock = this.uniformBlocks.get(uniformBufferName);\n    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n\n    let reason: false | string = false;\n    if (uniformBuffer && uniformBlock?.needsRedraw) {\n      reason ||= uniformBlock.needsRedraw;\n      // This clears the needs redraw flag\n      const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n\n      uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n      uniformBuffer?.write(uniformBufferData);\n\n      // logging - TODO - don't query the values unnecessarily\n      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();\n      log.log(\n        4,\n        `Writing to uniform buffer ${String(uniformBufferName)}`,\n        uniformBufferData,\n        uniformValues\n      )();\n    }\n    return reason;\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport type ImageData = {\n  /** Offset into the data (in addition to any offset built-in to the ArrayBufferView) */\n  byteOffset?: number;\n  /** The stride, in bytes, between the beginning of each texel block row and the subsequent texel block row. Required if there are multiple texel block rows (i.e. the copy height or depth is more than one block). */\n  bytesPerRow?: number;\n  /** Number or rows per image (needed if multiple images are being set) */\n  rowsPerImage?: number;\n  /** Bits per channel */\n  bitsPerChannel: [number, number, number, number];\n};\n\nexport type PixelData = {\n  arrayBuffer: ArrayBuffer;\n  width: number;\n  height: number;\n  /** Bytes per pixel */\n  bytesPerPixel: number;\n  bytesPerRow: number;\n  bitsPerChannel: [number, number, number, number];\n};\n\n/**\n * Extracts a single RGBA pixel value from PixelData at the given (x, y) coordinate.\n *\n * The pixel's data is assumed to be packed according to pixelData.bitsPerChannel.\n * The pixel data for a given row is padded to pixelData.bytesPerRow.\n *\n * @param pixelData - The metadata and data for the pixel buffer.\n * @param x - The x coordinate (0-based).\n * @param y - The y coordinate (0-based).\n * @returns A tuple [r, g, b, a] where each channel is the extracted numeric value.\n *\n* @example\n\nAssume you obtained an ArrayBuffer from copyTextureToBuffer and have the following metadata:\n\n  const pixelData: PixelData = {\n    bitsPerChannel: [5, 6, 5, 0], // For example, a 16-bit RGB565 format (no alpha)\n    width: 800,\n    height: 600,\n    bytesPerPixel: 2,           // 16 bits per pixel\n    bytesPerRow: 1600,          // Assuming no extra padding\n    arrayBuffer: myTextureBuffer, // Obtained from copyTextureToBuffer\n  };\n\nYou can then extract the pixel at (x, y) like so:\n\n  const rgba = extractPixel(pixelData, x, y);\n  console.log(\"Extracted RGBA:\", rgba);\n\nFor RGBA formats where all channels are present (e.g. [8, 8, 8, 8]), the function will extract a 4-channel pixel value.\n*/\n\nexport function readPixel(\n  pixelData: PixelData,\n  x: number,\n  y: number,\n  bitsPerChannel: [number, number, number, number]\n): [number, number, number, number] {\n  if (x < 0 || x >= pixelData.width || y < 0 || y >= pixelData.height) {\n    throw new Error('Coordinates out of bounds.');\n  }\n\n  // Compute the byte offset of the pixel in the buffer.\n  const byteOffset = y * pixelData.bytesPerRow + x * pixelData.bytesPerPixel;\n\n  // Create a Uint8Array view for this pixel's bytes.\n  // We only need to view pixelData.bytesPerPixel bytes.\n  const pixelDataView = new DataView(pixelData.arrayBuffer, byteOffset, pixelData.bytesPerPixel);\n\n  let bitOffsetWithinPixel = 0;\n  const channels: number[] = [];\n\n  // Extract each of the four channels.\n  for (let i = 0; i < 4; i++) {\n    const bits = bitsPerChannel[i];\n    // If a channel's bit width is zero or negative, consider it not present.\n    if (bits <= 0) {\n      channels.push(0);\n    } else {\n      const channelValue = readBitsFromDataView(pixelDataView, bitOffsetWithinPixel, bits);\n      channels.push(channelValue);\n      bitOffsetWithinPixel += bits;\n    }\n  }\n\n  return [channels[0], channels[1], channels[2], channels[3]];\n}\n\n/**\n * Encodes an RGBA pixel into a DataView at a given bit offset according to a specified bit layout.\n *\n * The channels are written sequentially in the order R, G, B, A. For each channel, the number\n * of bits is taken from the bitsPerChannel array. Channel values are masked to fit within the specified width.\n *\n * @param dataView - The DataView into which the pixel will be encoded.\n * @param bitOffset - The bit offset in the DataView where the pixel should be written.\n * @param bitsPerChannel - A tuple specifying the number of bits for each channel: [R, G, B, A].\n * @param pixel - A tuple [r, g, b, a] containing the channel values (as numbers).\n *\n * @example\n\nAssume you want to encode a pixel into a packed format where:\n  - Red uses 5 bits\n  - Green uses 6 bits\n  - Blue uses 5 bits\n  - Alpha is not used (0 bits)\nAnd the pixel format is packed into 16 bits total.\n\nYou might have:\n  const bitsPerChannel: [number, number, number, number] = [5, 6, 5, 0];\n  const pixel: [number, number, number, number] = [15, 31, 15, 0]; // Example values\n  const buffer = new ArrayBuffer(2); // 16 bits = 2 bytes\n  const dataView = new DataView(buffer);\n\nNow encode the pixel at bit offset 0:\n  encodePixel(dataView, 0, bitsPerChannel, pixel);\n\nThe dataView now contains the 16-bit packed pixel value in big-endian order.\n*/\nexport function writePixel(\n  dataView: DataView,\n  bitOffset: number,\n  bitsPerChannel: [number, number, number, number],\n  pixel: [number, number, number, number]\n): void {\n  let currentBitOffset = bitOffset;\n  for (let channel = 0; channel < 4; channel++) {\n    const bits = bitsPerChannel[channel];\n    // Clamp the channel value to the maximum allowed by the bit width.\n    const maxValue = (1 << bits) - 1;\n    const channelValue = pixel[channel] & maxValue;\n    writeBitsToDataView(dataView, currentBitOffset, bits, channelValue);\n    currentBitOffset += bits;\n  }\n}\n\n/**\n * Reads a specified number of bits from a DataView starting at a given bit offset.\n *\n * For channels with a bit width of 8, 16, or 32 bits and when the bitOffset is byte-aligned,\n * this function uses DataView methods for fast extraction.\n *\n * Bits are assumed to be stored in big-endian order (i.e. the most-significant bit is at position 7 in each byte).\n *\n * @param dataView - The DataView containing the data.\n * @param bitOffset - The offset (in bits) within the data from which to start reading.\n * @param bitCount - The number of bits to read (supported range: 1 to 32).\n * @returns The extracted value as a number.\n */\nexport function readBitsFromDataView(\n  dataView: DataView,\n  bitOffset: number,\n  bitCount: number\n): number {\n  // Check if we can optimize when bitOffset is byte-aligned.\n  if (bitOffset % 8 === 0) {\n    const byteOffset = bitOffset / 8;\n    if (bitCount === 8 && byteOffset + 1 <= dataView.byteLength) {\n      return dataView.getUint8(byteOffset);\n    } else if (bitCount === 16 && byteOffset + 2 <= dataView.byteLength) {\n      // false for big-endian reading.\n      return dataView.getUint16(byteOffset, false);\n    } else if (bitCount === 32 && byteOffset + 4 <= dataView.byteLength) {\n      return dataView.getUint32(byteOffset, false);\n    }\n  }\n\n  // Fallback: bit-level extraction for non-aligned or non-standard bit widths.\n  let value = 0;\n  for (let i = 0; i < bitCount; i++) {\n    const overallBitIndex = bitOffset + i;\n    const byteIndex = Math.floor(overallBitIndex / 8);\n    const bitIndex = overallBitIndex % 8;\n    // Read the byte and extract the bit at position (7 - bitIndex).\n    const byteValue = dataView.getUint8(byteIndex);\n    const bit = (byteValue >> (7 - bitIndex)) & 1;\n    value = (value << 1) | bit;\n  }\n  return value;\n}\n\n/**\n * Writes a specified number of bits from a value into a DataView at a given bit offset.\n *\n * For channels with a bit width of 8, 16, or 32 bits and when the bit offset is byte-aligned,\n * this function uses DataView methods for fast writing.\n *\n * Bits are assumed to be stored in big-endian order (i.e. the most-significant bit is at position 7 in each byte).\n *\n * @param dataView - The DataView to write into.\n * @param bitOffset - The bit offset at which to begin writing.\n * @param bitCount - The number of bits to write (supported range: 1 to 32).\n * @param value - The numeric value whose lower bitCount bits will be written.\n */\nexport function writeBitsToDataView(\n  dataView: DataView,\n  bitOffset: number,\n  bitCount: number,\n  value: number\n): void {\n  // If the bitOffset is byte-aligned, we may optimize for common bit widths.\n  if (bitOffset % 8 === 0) {\n    const byteOffset = bitOffset / 8;\n    if (bitCount === 8 && byteOffset + 1 <= dataView.byteLength) {\n      dataView.setUint8(byteOffset, value & 0xff);\n      return;\n    } else if (bitCount === 16 && byteOffset + 2 <= dataView.byteLength) {\n      dataView.setUint16(byteOffset, value & 0xffff, false); // big-endian\n      return;\n    } else if (bitCount === 32 && byteOffset + 4 <= dataView.byteLength) {\n      dataView.setUint32(byteOffset, value, false); // big-endian\n      return;\n    }\n  }\n\n  // Fallback: write bit-by-bit.\n  for (let i = 0; i < bitCount; i++) {\n    const overallBitIndex = bitOffset + i;\n    const byteIndex = Math.floor(overallBitIndex / 8);\n    const bitIndex = overallBitIndex % 8;\n    const mask = 1 << (7 - bitIndex);\n    // Extract the i-th bit from value (starting from the most-significant bit)\n    const bitValue = (value >> (bitCount - 1 - i)) & 1;\n    // Read the current byte.\n    let currentByte = dataView.getUint8(byteIndex);\n    // Clear the target bit.\n    currentByte &= ~mask;\n    // Set the target bit if bitValue is 1.\n    if (bitValue) {\n      currentByte |= mask;\n    }\n    dataView.setUint8(byteIndex, currentByte);\n  }\n}\n"],
  "mappings": "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",
  "names": ["Buffer", "name", "name", "arrayBuffer", "Buffer", "Buffer", "import_env", "log", "attachment", "name", "attributeMapping", "arrayBuffer", "name", "Buffer"]
}
